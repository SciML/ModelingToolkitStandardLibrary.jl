<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Theory · ModelingToolkitStandardLibrary.jl</title><meta name="title" content="Theory · ModelingToolkitStandardLibrary.jl"/><meta property="og:title" content="Theory · ModelingToolkitStandardLibrary.jl"/><meta property="twitter:title" content="Theory · ModelingToolkitStandardLibrary.jl"/><meta name="description" content="Documentation for ModelingToolkitStandardLibrary.jl."/><meta property="og:description" content="Documentation for ModelingToolkitStandardLibrary.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkitStandardLibrary.jl."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/connectors/connections/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/connectors/connections/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/connectors/connections/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ModelingToolkitStandardLibrary.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkitStandardLibrary.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/rc_circuit/">RC Circuit</a></li><li><a class="tocitem" href="../../tutorials/custom_component/">Custom Components</a></li><li><a class="tocitem" href="../../tutorials/thermal_model/">Thermal Conduction Model</a></li><li><a class="tocitem" href="../../tutorials/dc_motor_pi/">DC Motor with Speed Controller</a></li><li><a class="tocitem" href="../../tutorials/input_component/">SampledData Component</a></li></ul></li><li><span class="tocitem">About Acausal Connections</span><ul><li class="is-active"><a class="tocitem" href>Theory</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Through-and-Across-Variable-Theory"><span>Through and Across Variable Theory</span></a></li><li class="toplevel"><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li class="toplevel"><a class="tocitem" href="#Mechanical/Translational-Library-Differences-(Velocity-vs.-Position-Connectors)"><span>Mechanical/Translational Library Differences (Velocity vs. Position Connectors)</span></a></li><li><a class="tocitem" href="#Initialization"><span>Initialization</span></a></li><li><a class="tocitem" href="#Accuracy"><span>Accuracy</span></a></li></ul></li><li><a class="tocitem" href="../sign_convention/">Sign Convention</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/blocks/">Basic Blocks</a></li><li><a class="tocitem" href="../../API/electrical/">Electrical Components</a></li><li><a class="tocitem" href="../../API/magnetic/">Magnetic Components</a></li><li><a class="tocitem" href="../../API/mechanical/">Mechanical Components</a></li><li><a class="tocitem" href="../../API/thermal/">Thermal Components</a></li><li><a class="tocitem" href="../../API/hydraulic/">Hydraulic Components</a></li><li><a class="tocitem" href="../../API/linear_analysis/">Linear Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">About Acausal Connections</a></li><li class="is-active"><a href>Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Theory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitStandardLibrary.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitStandardLibrary.jl/blob/main/docs/src/connectors/connections.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>In Physical Network Acausal modeling, each physical domain must define a <strong>connector</strong> to combine model components.  Each physical domain <strong>connector</strong> defines a minimum of 2 variables, one which is called a <em>Through</em> variable, and one which is called an <em>Across</em> variable.  Both Modelica and SimScape define these variables in the same way:</p><ul><li><a href="https://mbe.modelica.university/components/connectors/#acausal-connection">Modelica Connectors</a></li><li><a href="https://www.mathworks.com/help/simscape/ug/basic-principles-of-modeling-physical-networks.html#bq89sba-6">SimScape Connectors</a></li></ul><p>However, the standard libraries differ on the selection of the Across variable for the Mechanical Translation and Rotation libraries, Modelica choosing position and angle and SimScape choosing velocity and angular velocity, respectively for Translation and Rotation.  Modelica describes their decision <a href="https://mbe.modelica.university/components/connectors/simple_domains/">here</a>.  In summary, they would like to provide less integration in the model to avoid lossy numerical behavior, but this decision assumes the lowest order derivative is needed by the model.  Numerically it is possible to define the connector either way, but there are some consequences of this decision, and therefore we will study them in detail here as they relate to ModelingToolkit.</p><h1 id="Through-and-Across-Variable-Theory"><a class="docs-heading-anchor" href="#Through-and-Across-Variable-Theory">Through and Across Variable Theory</a><a id="Through-and-Across-Variable-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Through-and-Across-Variable-Theory" title="Permalink"></a></h1><h3 id="General"><a class="docs-heading-anchor" href="#General">General</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></h3><p>The idea behind the selection of the <strong>through</strong> variable is that it should be a time derivative of some conserved quantity. The conserved quantity should be expressed by the <strong>across</strong> variable.  In general terms, the physical system is given by</p><ul><li>Energy Dissipation &amp; Flow:</li></ul><p class="math-container">\[\begin{aligned}
    \partial {\color{blue}{across}} / \partial t \cdot c_1 = {\color{green}{through}}  \\
    {\color{green}{through}} \cdot c_2 = {\color{blue}{across}}
\end{aligned}\]</p><h3 id="Electrical"><a class="docs-heading-anchor" href="#Electrical">Electrical</a><a id="Electrical-1"></a><a class="docs-heading-anchor-permalink" href="#Electrical" title="Permalink"></a></h3><p>For the Electrical domain, the across variable is <em>voltage</em> and the through variable <em>current</em>.  Therefore</p><ul><li>Energy Dissipation:</li></ul><p class="math-container">\[\partial {\color{blue}{voltage}} / \partial t \cdot capacitance = {\color{green}{current}}\]</p><ul><li>Flow:</li></ul><p class="math-container">\[{\color{green}{current}} \cdot resistance = {\color{blue}{voltage}}\]</p><h3 id="Translational"><a class="docs-heading-anchor" href="#Translational">Translational</a><a id="Translational-1"></a><a class="docs-heading-anchor-permalink" href="#Translational" title="Permalink"></a></h3><p>For the translation domain, choosing <em>velocity</em> for the across variable and <em>force</em> for the through gives</p><ul><li>Energy Dissipation:</li></ul><p class="math-container">\[\partial {\color{blue}{velocity}} / \partial t \cdot mass = {\color{green}{force}}\]</p><ul><li>Flow:</li></ul><p class="math-container">\[{\color{green}{force}} \cdot (1/damping) = {\color{blue}{velocity}}\]</p><p>The diagram here shows the similarity of problems in different physical domains.</p><p><img src="../through_across.png" alt="Through and Across Variables"/></p><h3 id="Translational-Connector-using-*Position*-Across-Variable"><a class="docs-heading-anchor" href="#Translational-Connector-using-*Position*-Across-Variable">Translational Connector using <em>Position</em> Across Variable</a><a id="Translational-Connector-using-*Position*-Across-Variable-1"></a><a class="docs-heading-anchor-permalink" href="#Translational-Connector-using-*Position*-Across-Variable" title="Permalink"></a></h3><p>Now, if we choose <em>position</em> for the across variable, a similar relationship can be established, but the pattern must be broken.</p><ul><li>Energy Dissipation:</li></ul><p class="math-container">\[\partial^2 {\color{blue}{position}} / \partial t^2 \cdot mass = {\color{green}{force}}\]</p><ul><li>Flow:</li></ul><p class="math-container">\[{\color{green}{force}} \cdot (1/damping) = \partial {\color{blue}{position}} / \partial t\]</p><p>As can be seen, we must now establish a higher order derivative to define the Energy Dissipation and Flow equations, requiring an extra equation, as will be shown in the example below.</p><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h3 id="Electrical-Domain"><a class="docs-heading-anchor" href="#Electrical-Domain">Electrical Domain</a><a id="Electrical-Domain-1"></a><a class="docs-heading-anchor-permalink" href="#Electrical-Domain" title="Permalink"></a></h3><p>We can generate the above relationship with ModelingToolkit and the ModelingToolkitStandardLibrary using 3 blocks:</p><ul><li>Capacitor: for energy storage with initial voltage = 1V</li><li>Resistor: for energy flow</li><li>Ground: for energy sink</li></ul><p>As can be seen, this will give a 1 equation model matching our energy dissipation relationship</p><pre><code class="language-julia hljs">using ModelingToolkitStandardLibrary.Electrical, ModelingToolkit, OrdinaryDiffEq
using ModelingToolkit: t_nounits as t
using Plots

systems = @named begin
    resistor = Resistor(R = 1)
    capacitor = Capacitor(C = 1)
    ground = Ground()
end

eqs = [connect(capacitor.p, resistor.p)
       connect(resistor.n, ground.g, capacitor.n)]

@named model = ODESystem(eqs, t; systems)

sys = structural_simplify(model)

println.(equations(sys))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Differential(t)(capacitor₊v(t)) ~ capacitor₊i(t) / capacitor₊C</code></pre><p>The solution shows what we would expect, a non-linear dissipation of voltage and related decrease in current flow…</p><pre><code class="language-julia hljs">prob = ODEProblem(sys, [1.0], (0, 10.0), [])
sol = solve(prob)

p1 = plot(sol, idxs = [capacitor.v])
p2 = plot(sol, idxs = [resistor.i])
plot(p1, p2)</code></pre><img src="b436e6b8.svg" alt="Example block output"/><h3 id="Mechanical-Translational-Domain"><a class="docs-heading-anchor" href="#Mechanical-Translational-Domain">Mechanical Translational Domain</a><a id="Mechanical-Translational-Domain-1"></a><a class="docs-heading-anchor-permalink" href="#Mechanical-Translational-Domain" title="Permalink"></a></h3><h4 id="Across-Variable-velocity"><a class="docs-heading-anchor" href="#Across-Variable-velocity">Across Variable = velocity</a><a id="Across-Variable-velocity-1"></a><a class="docs-heading-anchor-permalink" href="#Across-Variable-velocity" title="Permalink"></a></h4><p>Now using the Translational library based on velocity, we can see the same relationship with a system reduced to a single equation, using the components:</p><ul><li>Body (i.e. moving mass): for kinetic energy storage with an initial velocity = 1m/s</li><li>Damper: for energy flow</li><li>Fixed: for energy sink</li></ul><pre><code class="language-julia hljs">using ModelingToolkitStandardLibrary
const TV = ModelingToolkitStandardLibrary.Mechanical.Translational

systems = @named begin
    damping = TV.Damper(d = 1)
    body = TV.Mass(m = 1)
    ground = TV.Fixed()
end

eqs = [connect(damping.flange_a, body.flange)
       connect(ground.flange, damping.flange_b)]

@named model = ODESystem(eqs, t; systems)

sys = structural_simplify(model)

println.(full_equations(sys))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Differential(t)(body₊s(t)) ~ body₊v(t)
Differential(t)(body₊v(t)) ~ body₊g + (-damping₊d*body₊v(t)) / body₊m</code></pre><p>As expected, we have a similar solution…</p><pre><code class="language-julia hljs">prob = ODEProblem(
    sys, [], (0, 10.0), []; initialization_eqs = [sys.body.s ~ 0, sys.body.v ~ 1])
sol_v = solve(prob)

p1 = plot(sol_v, idxs = [body.v])
p2 = plot(sol_v, idxs = [damping.f])
plot(p1, p2)</code></pre><img src="5468edb9.svg" alt="Example block output"/><h4 id="Across-Variable-position"><a class="docs-heading-anchor" href="#Across-Variable-position">Across Variable = position</a><a id="Across-Variable-position-1"></a><a class="docs-heading-anchor-permalink" href="#Across-Variable-position" title="Permalink"></a></h4><p>Now, let&#39;s consider the position-based approach.  We can build the same model with the same components.  As can be seen, we now end of up with 2 equations, because we need to relate the lower derivative (position) to force (with acceleration).</p><pre><code class="language-julia hljs">const TP = ModelingToolkitStandardLibrary.Mechanical.TranslationalPosition

systems = @named begin
    damping = TP.Damper(d = 1, va = 1, vb = 0.0)
    body = TP.Mass(m = 1, v = 1)
    ground = TP.Fixed(s_0 = 0)
end

eqs = [connect(damping.flange_a, body.flange)
       connect(ground.flange, damping.flange_b)]

@named model = ODESystem(eqs, t; systems)

sys = structural_simplify(model)

println.(full_equations(sys))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Differential(t)(body₊s(t)) ~ body₊v(t)
Differential(t)(body₊v(t)) ~ (-damping₊d*body₊v(t)) / body₊m</code></pre><p>As can be seen, we get exactly the same result.  The only difference here is that we are solving an extra equation, which allows us to plot the body position as well.</p><pre><code class="language-julia hljs">prob = ODEProblem(sys, [], (0, 10.0), [])
sol_p = solve(prob)

p1 = plot(sol_p, idxs = [body.v])
p2 = plot(sol_p, idxs = [damping.f])
p3 = plot(sol_p, idxs = [body.s])

plot(p1, p2, p3)</code></pre><img src="70d4f345.svg" alt="Example block output"/><p>The question then arises, can the position be plotted when using the Mechanical Translational Domain based on the Velocity Across variable?  Yes, we can!  There are 2 solutions:</p><ol><li>the <code>Mass</code> component will add the position variable when the <code>s</code> parameter is used to set an initial position. Otherwise, the component does not track the position.</li></ol><pre><code class="language-julia hljs">@named body = TV.Mass(m = 1, v = 1, s = 0)</code></pre><ol><li>implement a <code>PositionSensor</code> TODO: Implement Translation Sensors</li></ol><p>Either option will produce the same result regardless of which across variable is used.  If the same result is given, why are both options included in the Standard Library, what are the differences?  These differences will be discussed next so that an informed decision can be made about which domain is best for your model.</p><h1 id="Mechanical/Translational-Library-Differences-(Velocity-vs.-Position-Connectors)"><a class="docs-heading-anchor" href="#Mechanical/Translational-Library-Differences-(Velocity-vs.-Position-Connectors)">Mechanical/Translational Library Differences (Velocity vs. Position Connectors)</a><a id="Mechanical/Translational-Library-Differences-(Velocity-vs.-Position-Connectors)-1"></a><a class="docs-heading-anchor-permalink" href="#Mechanical/Translational-Library-Differences-(Velocity-vs.-Position-Connectors)" title="Permalink"></a></h1><h2 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h2><p>The main difference between <code>ModelingToolkitStandardLibrary.Mechanical.Translational</code> and <code>ModelingToolkitStandardLibrary.Mechanical.TranslationalPosition</code> is how they are initialized.  In the <code>ModelingToolkitStandardLibrary</code> initialization, parameters are defined at the component level, so we simply need to be careful to set the correct initial conditions for the domain that it used.  Let&#39;s use the following example problem to explain the differences.</p><p><img src="../model.png" alt="Example Mechanical Model"/></p><p>In this problem, we have a mass, spring, and damper which are connected to a fixed point.  Let&#39;s see how each component is defined.</p><h4 id="Damper"><a class="docs-heading-anchor" href="#Damper">Damper</a><a id="Damper-1"></a><a class="docs-heading-anchor-permalink" href="#Damper" title="Permalink"></a></h4><p>The damper will connect the flange/flange 1 (<code>flange_a</code>) to the mass, and flange/flange 2 (<code>flange_b</code>) to the fixed point.  For both position- and velocity-based domains, we set the damping constant <code>d=1</code> and <code>va=1</code> and leave the default for <code>v_b_0</code> at 0.  For the position domain, we also need to set the initial positions for <code>flange_a</code> and <code>flange_b</code>.</p><pre><code class="language-julia hljs">@named dv = TV.Damper(d = 1)
@named dp = TP.Damper(d = 1, va = 1, vb = 0.0, flange_a__s = 3, flange_b__s = 1)</code></pre><h4 id="Spring"><a class="docs-heading-anchor" href="#Spring">Spring</a><a id="Spring-1"></a><a class="docs-heading-anchor-permalink" href="#Spring" title="Permalink"></a></h4><p>The spring will connect the flange/flange 1 (<code>flange_a</code>) to the mass, and flange/flange 2 (<code>flange_b</code>) to the fixed point.  For both position- and velocity-based domains, we set the spring constant <code>k=1</code>.  The velocity domain then requires the initial velocity <code>va</code> and initial spring stretch <code>delta_s</code>.  The position domain instead needs the initial positions for <code>flange_a</code> and <code>flange_b</code> and the natural spring length <code>l</code>.</p><pre><code class="language-julia hljs">@named sv = TV.Spring(k = 1)
@named sp = TP.Spring(k = 1, flange_a__s = 3, flange_b__s = 1, l = 1)</code></pre><h4 id="Mass"><a class="docs-heading-anchor" href="#Mass">Mass</a><a id="Mass-1"></a><a class="docs-heading-anchor-permalink" href="#Mass" title="Permalink"></a></h4><p>For both position- and velocity-based domains, we set the mass <code>m=1</code> and initial velocity <code>v=1</code>. Like the damper, the position domain requires the position initial conditions set as well.</p><pre><code class="language-julia hljs">@named bv = TV.Mass(m = 1)
@named bp = TP.Mass(m = 1, v = 1, s = 3)</code></pre><h4 id="Fixed"><a class="docs-heading-anchor" href="#Fixed">Fixed</a><a id="Fixed-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed" title="Permalink"></a></h4><p>Here the velocity domain requires no initial condition, but for our model to work as defined we must set the position domain component to the correct initial position.</p><pre><code class="language-julia hljs">@named gv = TV.Fixed()
@named gp = TP.Fixed(s_0 = 1)</code></pre><h3 id="Comparison"><a class="docs-heading-anchor" href="#Comparison">Comparison</a><a id="Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison" title="Permalink"></a></h3><p>As can be seen, the position-based domain requires more initial condition information to be properly defined, since the absolute position information is required. Therefore, based on the model being described, it may be more natural to choose one domain over the other.</p><p>Let&#39;s define a quick function to simplify and solve the 2 different systems. Note, we will solve with a fixed time step and a set tolerance to compare the numerical differences.</p><pre><code class="language-julia hljs">function simplify_and_solve(damping, spring, body, ground; initialization_eqs = Equation[])
    eqs = [connect(spring.flange_a, body.flange, damping.flange_a)
           connect(spring.flange_b, damping.flange_b, ground.flange)]

    @named model = ODESystem(eqs, t; systems = [ground, body, spring, damping])

    sys = structural_simplify(model)

    println.(full_equations(sys))

    prob = ODEProblem(sys, [], (0, 10.0), []; initialization_eqs)
    sol = solve(prob; abstol = 1e-9, reltol = 1e-9)

    return sol
end</code></pre><p>Now let&#39;s solve the velocity domain model</p><pre><code class="language-julia hljs">initialization_eqs = [bv.s ~ 3
                      bv.v ~ 1
                      sv.delta_s ~ 1]
solv = simplify_and_solve(dv, sv, bv, gv; initialization_eqs);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Differential(t)(bv₊s(t)) ~ bv₊v(t)
Differential(t)(bv₊v(t)) ~ bv₊g + (-dv₊d*bv₊v(t) - sv₊k*sv₊delta_s(t)) / bv₊m
Differential(t)(sv₊delta_s(t)) ~ bv₊v(t)</code></pre><p>And the position domain model</p><pre><code class="language-julia hljs">solp = simplify_and_solve(dp, sp, bp, gp);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Differential(t)(bp₊s(t)) ~ bp₊v(t)
Differential(t)(bp₊v(t)) ~ (-dp₊d*bp₊v(t) - (-gp₊s_0 - sp₊l + bp₊s(t))*sp₊k) / bp₊m
┌ Warning: Initialization system is overdetermined. 14 equations for 1 unknowns. Initialization will default to using least squares. `SCCNonlinearProblem` can only be used for initialization of fully determined systems and hence will not be used here. To suppress this warning pass warn_initialize_determined = false. To make this warning into an error, pass fully_determined = true
└ @ ModelingToolkit ~/.julia/packages/ModelingToolkit/KpwHT/src/systems/diffeqs/abstractodesystem.jl:1517</code></pre><p>Now we can plot the comparison of the 2 models and see they give the same result.</p><pre><code class="language-julia hljs">plot(ylabel = &quot;mass velocity [m/s]&quot;)
plot!(solv, idxs = [bv.v])
plot!(solp, idxs = [bp.v])</code></pre><img src="5cb94ed0.svg" alt="Example block output"/><p>But, what if we wanted to plot the mass position?  This is easy for the position-based domain, we have the state <code>bp₊s(t)</code>, but for the velocity-based domain we have <code>sv₊delta_s(t)</code> which is the spring stretch.  To get the absolute position, we add the spring natural length (1m) and the fixed position (1m).  As can be seen, we then get the same result.</p><pre><code class="language-julia hljs">plot(ylabel = &quot;mass position [m]&quot;)
plot!(solv, idxs = [sv.delta_s + 1 + 1])
plot!(solp, idxs = [bp.s])</code></pre><img src="ac221a69.svg" alt="Example block output"/><p>So in conclusion, the position based domain gives easier access to absolute position information, but requires more initial condition information.</p><h2 id="Accuracy"><a class="docs-heading-anchor" href="#Accuracy">Accuracy</a><a id="Accuracy-1"></a><a class="docs-heading-anchor-permalink" href="#Accuracy" title="Permalink"></a></h2><p>One may then ask, what the trade-off in terms of numerical accuracy is. When we look at the simplified equations, we can see that actually both systems solve the same equations.  The differential equations of the velocity domain are</p><p class="math-container">\[\begin{aligned}
m \cdot \dot{v} +  d \cdot v + k \cdot \Delta s = 0  \\
\dot{\Delta s} = v
\end{aligned}\]</p><p>And for the position domain are</p><p class="math-container">\[\begin{aligned}
m \cdot \dot{v} +  d \cdot v + k \cdot (s - s_{b_0} - l) = 0   \\
\dot{s} = v
\end{aligned}\]</p><p>By definition, the spring stretch is</p><p class="math-container">\[\Delta s = s - s_{b_0} - l\]</p><p>Which means both systems are actually solving the same exact system.  We can plot the numerical difference between the 2 systems and see the result is negligible (much less than the tolerance of 1e-9).</p><pre><code class="language-julia hljs">plot(title = &quot;numerical difference: vel. vs. pos. domain&quot;, xlabel = &quot;time [s]&quot;,
    ylabel = &quot;solv[bv.v] .- solp[bp.v]&quot;)
time = 0:0.1:10
plot!(time, (solv(time)[bv.v] .- solp(time)[bp.v]), label = &quot;&quot;)</code></pre><img src="0d2812bb.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/input_component/">« SampledData Component</a><a class="docs-footer-nextpage" href="../sign_convention/">Sign Convention »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Thursday 1 May 2025 19:02">Thursday 1 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
