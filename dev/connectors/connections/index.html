<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>About Acausal Connections · ModelingToolkitStandardLibrary.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/connectors/connections/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ModelingToolkitStandardLibrary.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkitStandardLibrary.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/rc_circuit/">RC Circuit</a></li><li><a class="tocitem" href="../../tutorials/custom_component/">Custom Components</a></li><li><a class="tocitem" href="../../tutorials/thermal_model/">Thermal Conduction Model</a></li><li><a class="tocitem" href="../../tutorials/dc_motor_pi/">DC Motor with Speed Controller</a></li></ul></li><li class="is-active"><a class="tocitem" href>About Acausal Connections</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Through-and-Across-Variable-Theory"><span>Through and Across Variable Theory</span></a></li><li class="toplevel"><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li class="toplevel"><a class="tocitem" href="#Mechanical/Translational-Library-Differences-(Velocity-vs.-Position-Connectors)"><span>Mechanical/Translational Library Differences (Velocity vs. Position Connectors)</span></a></li><li><a class="tocitem" href="#Initialization"><span>Initialization</span></a></li><li><a class="tocitem" href="#Acuracy"><span>Acuracy</span></a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/blocks/">Basic Blocks</a></li><li><a class="tocitem" href="../../API/electrical/">Electrical Components</a></li><li><a class="tocitem" href="../../API/magnetic/">Magnetic Components</a></li><li><a class="tocitem" href="../../API/mechanical/">Mechanical Components</a></li><li><a class="tocitem" href="../../API/thermal/">Thermal Components</a></li><li><a class="tocitem" href="../../API/linear_analysis/">Linear Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>About Acausal Connections</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>About Acausal Connections</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/ModelingToolkitStandardLibrary.jl/blob/main/docs/src/connectors/connections.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>In Physical Network Acausal modeling each physical domain must define a <strong>connector</strong> to combine model components.  Each physical domain <strong>connector</strong> defines a minimum of 2 variables, one which is called a <em>Through</em> variable, and one which is called an <em>Across</em> variable.  Both Modelica and SimScape define these variables in the same way:</p><ul><li><a href="https://mbe.modelica.university/components/connectors/#acausal-connection">Modelica Connectors</a></li><li><a href="https://www.mathworks.com/help/simscape/ug/basic-principles-of-modeling-physical-networks.html#bq89sba-6">SimScape Connectors</a></li></ul><p>However, the standard libraries differ on the selection of the Across variable for the Mechanical Translation and Rotation libraries, Modelica choosing position and angle and SimScape choosing velocity and angular velocity, respectively for Translation and Rotation.  Modelica describes their decision <a href="https://mbe.modelica.university/components/connectors/simple_domains/">here</a>.  In summary they would like to provide less integration in the model to avoid lossy numerical behavior, but this decision assumes the lowest order derivative is needed by the model.  Numerically it is possible to define the connector either way, but there are some consequences to this decision, and therefore we will study them in detail here as they relate to ModelingToolkit.  </p><h1 id="Through-and-Across-Variable-Theory"><a class="docs-heading-anchor" href="#Through-and-Across-Variable-Theory">Through and Across Variable Theory</a><a id="Through-and-Across-Variable-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Through-and-Across-Variable-Theory" title="Permalink"></a></h1><h3 id="General"><a class="docs-heading-anchor" href="#General">General</a><a id="General-1"></a><a class="docs-heading-anchor-permalink" href="#General" title="Permalink"></a></h3><p>The idea behind the selection of the <strong>through</strong> variable is that it should be a time derivative of some conserved quantity. The conserved quantity should be expressed by the <strong>across</strong> variable.  In general terms the physical system is given by</p><ul><li>Energy Dissipation &amp; Flow: </li></ul><p class="math-container">\[\begin{aligned}
    \partial {\color{blue}{across}} / \partial t \cdot c_1 = {\color{green}{through}}  \\
    {\color{green}{through}} \cdot c_2 = {\color{blue}{across}} 
\end{aligned}\]</p><h3 id="Electrical"><a class="docs-heading-anchor" href="#Electrical">Electrical</a><a id="Electrical-1"></a><a class="docs-heading-anchor-permalink" href="#Electrical" title="Permalink"></a></h3><p>For the Electrical domain the across variable is <em>voltage</em> and the through variable <em>current</em>.  Therefore </p><ul><li>Energy Dissipation: </li></ul><p class="math-container">\[\partial {\color{blue}{voltage}} / \partial t \cdot capacitance = {\color{green}{current}} \]</p><ul><li>Flow: </li></ul><p class="math-container">\[{\color{green}{current}} \cdot resistance = {\color{blue}{voltage}}\]</p><h3 id="Translational"><a class="docs-heading-anchor" href="#Translational">Translational</a><a id="Translational-1"></a><a class="docs-heading-anchor-permalink" href="#Translational" title="Permalink"></a></h3><p>For the translation domain, choosing <em>velocity</em> for the across variable and <em>force</em> for the through gives</p><ul><li>Energy Dissipation: </li></ul><p class="math-container">\[\partial {\color{blue}{velocity}} / \partial t \cdot mass = {\color{green}{force}} \]</p><ul><li>Flow: </li></ul><p class="math-container">\[{\color{green}{force}} \cdot (1/damping) = {\color{blue}{velocity}} \]</p><p>The diagram here shows the similarity of problems in different physical domains.  </p><p><img src="../through_across.png" alt="Through and Across Variables"/></p><h3 id="Translational-Connector-using-*Position*-Across-Variable"><a class="docs-heading-anchor" href="#Translational-Connector-using-*Position*-Across-Variable">Translational Connector using <em>Position</em> Across Variable</a><a id="Translational-Connector-using-*Position*-Across-Variable-1"></a><a class="docs-heading-anchor-permalink" href="#Translational-Connector-using-*Position*-Across-Variable" title="Permalink"></a></h3><p>Now, if we choose <em>position</em> for the across variable, a similar relationship can be established, but the patern must be broken.</p><ul><li>Energy Dissipation: </li></ul><p class="math-container">\[\partial^2 {\color{blue}{position}} / \partial t^2 \cdot mass = {\color{green}{force}} \]</p><ul><li>Flow: </li></ul><p class="math-container">\[{\color{green}{force}} \cdot (1/damping) = \partial {\color{blue}{position}} / \partial t \]</p><p>As can be seen, we must now establish a higher order derivative to define the Energy Dissipation and Flow equations, requiring an extra equation, as will be shown in the example below.</p><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h3 id="Electrical-Domain"><a class="docs-heading-anchor" href="#Electrical-Domain">Electrical Domain</a><a id="Electrical-Domain-1"></a><a class="docs-heading-anchor-permalink" href="#Electrical-Domain" title="Permalink"></a></h3><p>We can generate the above relationship with ModelingToolkit and the ModelingToolkitStandardLibrary using 3 blocks:</p><ul><li>Capacitor: for energy storage with initial voltage = 1V</li><li>Resistor: for energy flow</li><li>Ground: for energy sink</li></ul><p>As can be seen, this will give a 1 equation model matching our energy dissipation relationship</p><pre><code class="language-julia hljs">using ModelingToolkitStandardLibrary.Electrical, ModelingToolkit, DifferentialEquations
using Plots

@parameters t

@named resistor = Resistor(R = 1)
@named capacitor = Capacitor(C = 1)
@named ground = Ground()

eqs = [
    connect(capacitor.p, resistor.p)
    connect(resistor.n, ground.g, capacitor.n)
    ]

@named model = ODESystem(eqs, t; systems=[resistor, capacitor, ground])

sys = structural_simplify(model)

println.(equations(sys))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Differential(t)(capacitor₊v(t)) ~ capacitor₊i(t) / capacitor₊C</code></pre><p>The solution shows what we would expect, a non-linear disipation of voltage and releated decrease in current flow...</p><pre><code class="language-julia hljs">prob = ODEProblem(sys, [1.0], (0, 10.0), [])
sol = solve(prob)

p1=plot(sol, idxs=[capacitor.v])
p2=plot(sol, idxs=[resistor.i])
plot(p1,p2)</code></pre><p><img src="../electrical.png" alt="Plot of Electrical Example"/></p><h3 id="Mechanical-Translational-Domain"><a class="docs-heading-anchor" href="#Mechanical-Translational-Domain">Mechanical Translational Domain</a><a id="Mechanical-Translational-Domain-1"></a><a class="docs-heading-anchor-permalink" href="#Mechanical-Translational-Domain" title="Permalink"></a></h3><h4 id="Across-Variable-velocity"><a class="docs-heading-anchor" href="#Across-Variable-velocity">Across Variable = velocity</a><a id="Across-Variable-velocity-1"></a><a class="docs-heading-anchor-permalink" href="#Across-Variable-velocity" title="Permalink"></a></h4><p>Now using the Translational library based on velocity, we can see the same relationship with a system reduced to a single equation, using the components:</p><ul><li>Body (i.e. moving mass): for kinetic energy storage with an initial velocity = 1m/s</li><li>Damper: for energy flow</li><li>Fixed: for energy sink</li></ul><pre><code class="language-julia hljs">using ModelingToolkitStandardLibrary
const TV = ModelingToolkitStandardLibrary.Mechanical.Translational

@named damping = TV.Damper(d=1, v_a_0=1)
@named body = TV.Mass(m=1, v_0=1)
@named ground = TV.Fixed()

eqs = [
    connect(damping.flange_a, body.flange)
    connect(ground.flange, damping.flange_b)
    ]

@named model = ODESystem(eqs, t; systems=[damping, body, ground])

sys = structural_simplify(model)

println.(full_equations(sys))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Differential(t)(body₊v(t)) ~ (-damping₊d*body₊v(t)) / body₊m</code></pre><p>As expected we have a similar solution...</p><pre><code class="language-julia hljs">prob = ODEProblem(sys, [], (0, 10.0), [])
sol_v = solve(prob)

p1=plot(sol_v, idxs=[body.v])
p2=plot(sol_v, idxs=[damping.f])
plot(p1,p2)</code></pre><p><img src="../mechanical_velocity.png" alt="Plot of Mechanical (Velocity Based) Example"/></p><h4 id="Across-Variable-position"><a class="docs-heading-anchor" href="#Across-Variable-position">Across Variable = position</a><a id="Across-Variable-position-1"></a><a class="docs-heading-anchor-permalink" href="#Across-Variable-position" title="Permalink"></a></h4><p>Now, let&#39;s consider the position based approach.  We can build the same model with the same components.  As can be seen, we now end of up with 2 equations, because we need to relate the lower derivative (position) to force (with acceleration).  </p><pre><code class="language-julia hljs">const TP = ModelingToolkitStandardLibrary.Mechanical.TranslationalPosition

@named damping = TP.Damper(d=1, v_a_0=1)
@named body =    TP.Mass(m=1, v_0=1)
@named ground =  TP.Fixed(s_0=0)

    eqs = [
        connect(damping.flange_a, body.flange)
        connect(ground.flange, damping.flange_b)
        ]

@named model = ODESystem(eqs, t; systems=[damping, body, ground])

sys = structural_simplify(model)

println.(full_equations(sys))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Differential(t)(damping₊flange_a₊s(t)) ~ body₊v(t)
Differential(t)(body₊v(t)) ~ -((damping₊d*body₊v(t)) / body₊m)</code></pre><p>As can be seen, we get exactly the same result.  The only difference here is that we are solving an extra equation, which allows us to plot the body position as well.</p><pre><code class="language-julia hljs">prob = ODEProblem(sys, [], (0, 10.0), [])
sol_p = solve(prob)

p1=plot(sol_p, idxs=[body.v])
p2=plot(sol_p, idxs=[damping.f])
p3=plot(sol_p, idxs=[body.s])

plot(p1,p2,p3)</code></pre><p><img src="../mechanical_position.png" alt="Plot of Mechanical (Velocity Based) Example"/></p><p>The question then arises, can the position be plotted when using the Mechanical Translational Domain based on the Velocity Across variable?  Yes, we can!  There are 2 solutions:</p><ol><li>the <code>Mass</code> component will add the position variable when the <code>s_0</code> parameter is used to set an initial position.  Otherwise the position is not tracked by the component.</li></ol><pre><code class="language-julia hljs">@named body = TV.Mass(m=1,  v_0=1,  s_0=0)</code></pre><ol><li>implement a <code>PositionSensor</code></li></ol><p>TODO: Implement Translation Sensors</p><p>Either option will produce the same result regardless of which across variable is used.  If the same result is given, why are both options included in the Standard Library, what are the differences?  These differences will be discussed next so that an informed decision can be made about which domain is best for your model.</p><h1 id="Mechanical/Translational-Library-Differences-(Velocity-vs.-Position-Connectors)"><a class="docs-heading-anchor" href="#Mechanical/Translational-Library-Differences-(Velocity-vs.-Position-Connectors)">Mechanical/Translational Library Differences (Velocity vs. Position Connectors)</a><a id="Mechanical/Translational-Library-Differences-(Velocity-vs.-Position-Connectors)-1"></a><a class="docs-heading-anchor-permalink" href="#Mechanical/Translational-Library-Differences-(Velocity-vs.-Position-Connectors)" title="Permalink"></a></h1><h2 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h2><p>The main difference between <code>ModelingToolkitStandardLibrary.Mechanical.Translational</code> and <code>ModelingToolkitStandardLibrary.Mechanical.TranslationalPosition</code> is how they are initialized.  In the <code>ModelingToolkitStandardLibrary</code> initialization parameters are defined at the component level, so we simply need to be careful to set the correct initial conditions for the domain that it used.  Let&#39;s use the following example problem to explain the differences.  </p><p><img src="../model.png" alt="Example Mechanical Model"/></p><p>In this problem we have a mass, spring, and damper which are connected to a fixed point.  Let&#39;s see how each component is defined.</p><h4 id="Damper"><a class="docs-heading-anchor" href="#Damper">Damper</a><a id="Damper-1"></a><a class="docs-heading-anchor-permalink" href="#Damper" title="Permalink"></a></h4><p>The damper will connect the flange/flange 1 (<code>flange_a</code>) to the mass, and flange/flange 2 (<code>flange_b</code>) to the fixed point.  For both position and velocity based domains, we set the damping constant <code>d=1</code> and <code>v_a_0=1</code> and leave the default for <code>v_b_0</code> at 0.  For the position domain we also need to set the initial positions for <code>flange_a</code> and <code>flange_b</code>.</p><pre><code class="language-julia hljs">@named dv = TV.Damper(d=1, v_a_0=1)
@named dp = TP.Damper(d=1, v_a_0=1, s_a_0=3, s_b_0=1)</code></pre><h4 id="Spring"><a class="docs-heading-anchor" href="#Spring">Spring</a><a id="Spring-1"></a><a class="docs-heading-anchor-permalink" href="#Spring" title="Permalink"></a></h4><p>The spring will connect the flange/flange 1 (<code>flange_a</code>) to the mass, and flange/flange 2 (<code>flange_b</code>) to the fixed point.  For both position and velocity based domains, we set the spring constant <code>k=1</code>.  The velocity domain then requires the initial velocity <code>v_a_0</code> and initial spring stretch <code>delta_s_0</code>.  The position domain instead needs the initial positions for <code>flange_a</code> and <code>flange_b</code> and the natural spring length <code>l</code>.  </p><pre><code class="language-julia hljs">@named sv = TV.Spring(k=1, v_a_0=1, delta_s_0=1)
@named sp = TP.Spring(k=1, s_a_0=3, s_b_0=1, l=1)</code></pre><h4 id="Mass"><a class="docs-heading-anchor" href="#Mass">Mass</a><a id="Mass-1"></a><a class="docs-heading-anchor-permalink" href="#Mass" title="Permalink"></a></h4><p>For both position and velocity based domains, we set the mass <code>m=1</code> and initial velocity <code>v_0=1</code>. Like the damper, the position domain requires the position initial conditions set as well.  </p><pre><code class="language-julia hljs">@named bv = TV.Mass(m=1, v_0=1)
@named bp = TP.Mass(m=1, v_0=1, s_0=3)</code></pre><h4 id="Fixed"><a class="docs-heading-anchor" href="#Fixed">Fixed</a><a id="Fixed-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed" title="Permalink"></a></h4><p>Here the velocity domain requires no initial condition, but for our model to work as defined we must set the position domain component to the correct intital position.</p><pre><code class="language-julia hljs">@named gv =  TV.Fixed()
@named gp =  TP.Fixed(s_0=1)</code></pre><h3 id="Comparison"><a class="docs-heading-anchor" href="#Comparison">Comparison</a><a id="Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison" title="Permalink"></a></h3><p>As can be seen, the position based domain requires more initial condition information to be properly defined since the absolute position information is required.  Thereore based on the model being described, it may be more natural to choose one domain over the other.  </p><p>Let&#39;s define a quick function to simplify and solve the 2 different systems.  Note we will solve with a fixed time step and a set tolerance to compare the numerical differences.</p><pre><code class="language-julia hljs">function simplify_and_solve(damping, spring, body, ground)

       eqs = [connect(spring.flange_a, body.flange, damping.flange_a)
              connect(spring.flange_b, damping.flange_b, ground.flange)
              ]

       @named model = ODESystem(eqs, t; systems = [ground, body, spring, damping])

       sys = structural_simplify(model)

       println.(full_equations(sys))

       prob = ODEProblem(sys, [], (0, 10.0), [])
       sol = solve(prob; dt=0.1, adaptive=false, reltol=1e-9, abstol=1e-9)

       return sol
end</code></pre><p>Now let&#39;s solve the velocity domain model</p><pre><code class="language-julia hljs">solv=simplify_and_solve(dv, sv, bv, gv);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Differential(t)(sv₊delta_s(t)) ~ dv₊flange_a₊v(t)
Differential(t)(dv₊flange_a₊v(t)) ~ -((-(-dv₊d*dv₊flange_a₊v(t) - sv₊k*sv₊delta_s(t))) / bv₊m)</code></pre><p>And the position domain model</p><pre><code class="language-julia hljs">solp=simplify_and_solve(dp, sp, bp, gp);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Differential(t)(bp₊s(t)) ~ dp₊v1(t)
Differential(t)(dp₊v1(t)) ~ -((-(-dp₊d*dp₊v1(t) - sp₊k*(bp₊s(t) - gp₊s_0 - sp₊l))) / bp₊m)</code></pre><p>Now we can plot the comparison of the 2 models and see they give the same result.  </p><pre><code class="language-julia hljs">plot(ylabel=&quot;mass velocity [m/s]&quot;)
plot!(solv, idxs=[bv.v])
plot!(solp, idxs=[bp.v])</code></pre><p><img src="../mass_velocity.png" alt="Mass Velocity Comparison"/></p><p>But, what if we wanted to plot the mass position?  This is easy for the position based domain, we have the state <code>bp₊s(t)</code>, but for the velocity based domain we have <code>sv₊delta_s(t)</code> which is the spring stretch.  To get the absolute position we add the spring natrual length (1m) and the fixed position (1m).  As can be seen, we then get the same result.</p><pre><code class="language-julia hljs">plot(ylabel=&quot;mass position [m]&quot;)
plot!(solv, idxs=[sv.delta_s + 1 + 1])
plot!(solp, idxs=[bp.s])</code></pre><p><img src="../mass_position.png" alt="Mass Position Comparison"/></p><p>So in conclusion, the position based domain gives easier access to absolute position information, but requires more initial condition information.  </p><h2 id="Acuracy"><a class="docs-heading-anchor" href="#Acuracy">Acuracy</a><a id="Acuracy-1"></a><a class="docs-heading-anchor-permalink" href="#Acuracy" title="Permalink"></a></h2><p>One may ask then what is the trade off in terms of numerical acuracy?  When we look at the simplified equations, we can see that actually both systems solve the same equations.  The differential equations of the velocity domain are</p><p class="math-container">\[\begin{aligned}
m \cdot \dot{v} +  d \cdot v + k \cdot \Delta s = 0  \\
\dot{\Delta s} = v
\end{aligned}\]</p><p>And for the position domain are</p><p class="math-container">\[\begin{aligned}
m \cdot \dot{v} +  d \cdot v + k \cdot (s - s_{b_0} - l) = 0   \\
\dot{s} = v
\end{aligned}\]</p><p>By definition the spring stretch is</p><p class="math-container">\[\Delta s = s - s_{b_0} - l\]</p><p>Which means both systems are actually solving the same exact system.  We can plot the numerical difference between the 2 systems and see the result is negligible.</p><pre><code class="language-julia hljs">plot(title=&quot;numerical difference: vel. vs. pos. domain&quot;, xlabel=&quot;time [s]&quot;, ylabel=&quot;solv[bv.v] .- solp[bp.v]&quot;)
time = 0:0.1:10
plot!(time, (solv(time)[bv.v] .- solp(time)[bp.v]), label=&quot;&quot;)
Plots.ylims!(-1e-15, 1e-15)</code></pre><p><img src="../err.png" alt="Accuracy Comparison"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/dc_motor_pi/">« DC Motor with Speed Controller</a><a class="docs-footer-nextpage" href="../../API/blocks/">Basic Blocks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 3 January 2023 15:50">Tuesday 3 January 2023</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
