var documenterSearchIndex = {"docs":
[{"location":"connectors/sign_convention/#Sign-Convention","page":"Sign Convention","title":"Sign Convention","text":"","category":"section"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"A sign convention is recommended for this library that implements the following rule:","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"An input component that specifies the through variable should be such that an oppossite equality is written such that when connected to a conserved quantity component (i.e. a mass or capacitor component) a positive value for a flow variable represents the accumulation of that conserved quantity over time in the component.","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"Note: that this implements the same convention as applied in Modelica Standard Library.","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"For example, the following would be the correct sign convention for the Mechanical.Translational force variable f","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"@mtkmodel ConstantForce begin\n    @parameters begin\n        f = 0\n    end\n    @components begin\n        flange = MechanicalPort()\n    end\n    @equations begin\n        # connectors\n        flange.f ~ -f # <-- force is leaving\n    end\nend","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"And writing the following would be the incorrect sign convention.","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"@equations begin\n    # connectors\n    flange.f ~ f # <-- wrong through variable input sign!\nend","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"<!– To visualize the sign convention, one can draw the orientation of the connector port across and through variables and the subsequent component variables.  For example, the Mechanical.Translation mass component would look like","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"(Image: mass)","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"In this case we know from Newton that mass times acceleration equals force, therefore the direction of movement is in the opposite direction of the force.  In other words, if we push the mass from left to right (i.e. in the positive direction), then the mass will generate a force in the negative direction.  This would be the general rule for a single port component of any domain.  The exception is for a through variable input component, which should align the component and port connection through variables.  For example, a force input diagram would look like this:","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"(Image: force)","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"For a 2 port connection component, then the through variable is exiting each connection port in opposing directions.  Using a damper as an example, if the positive direction is to the right, then the force of the damper is pushing left (i.e. in the negative direction) on connection port a and right (positive direction) on connection port b.","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"(Image: damper) –>","category":"page"},{"location":"connectors/sign_convention/#Discussion","page":"Sign Convention","title":"Discussion","text":"","category":"section"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"The energy dissipation equation that governs the acausal connection definitions should be such that a positive through variable input will lead to an increasing across variable value.","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"fracpartial blue acrosspartial t = text green through input","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"This is demonstrated in the following domains of Mechanical, Electrical, and Hydraulic.","category":"page"},{"location":"connectors/sign_convention/#Mechanical","page":"Sign Convention","title":"Mechanical","text":"","category":"section"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"The flow variable (i.e. force) input component for the Mechanical domain is","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"using ModelingToolkit\nusing ModelingToolkitStandardLibrary.Mechanical.Translational\nusing ModelingToolkit: t_nounits as t\n\n@mtkmodel ConstantForce begin\n    @parameters begin\n        f\n    end\n    @components begin\n        flange = MechanicalPort()\n    end\n    @equations begin\n        # connectors\n        flange.f ~ -f\n    end\nend","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"Here we can see that a positive input force results in an increasing velocity.","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"@mtkmodel System begin\n    @components begin\n        mass = Mass(; m = 10)\n        force = ConstantForce(; f = 1)\n    end\n    @equations begin\n        connect(mass.flange, force.flange)\n    end\nend\n@mtkbuild sys = System()\nfull_equations(sys)","category":"page"},{"location":"connectors/sign_convention/#Electrical","page":"Sign Convention","title":"Electrical","text":"","category":"section"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"The flow variable (i.e. current) input component for the Electrical domain is","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"using ModelingToolkitStandardLibrary.Electrical\n\n@mtkmodel ConstantCurrent begin\n    @parameters begin\n        i\n    end\n    @components begin\n        p = Pin()\n        n = Pin()\n    end\n    @equations begin\n        0 ~ p.i + n.i\n        i ~ -n.i # can also be written as i ~ p.i\n    end\nend","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"Here we can see that a positive input current results in an increasing voltage. Note that the electrical domain uses pins p and n at each side of the source and energy storage components.  The direction of connection is not important here, only that a positive connector p connects with a negative connector n.","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"@mtkmodel System begin\n    @components begin\n        capacitor = Capacitor(; C = 10)\n        current = ConstantCurrent(; i = 1)\n        ground = Ground()\n    end\n    @equations begin\n        connect(current.n, capacitor.p)\n        connect(capacitor.n, current.p, ground.g)\n    end\nend\n@mtkbuild sys = System()\nfull_equations(sys)","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"Reversing the pins gives the same result","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"@mtkmodel System begin\n    @components begin\n        capacitor = Capacitor(; C = 10)\n        current = ConstantCurrent(; i = 1)\n        ground = Ground()\n    end\n    @equations begin\n        connect(current.p, capacitor.n)\n        connect(capacitor.p, current.n, ground.g)\n    end\nend\n@mtkbuild sys = System()\nfull_equations(sys)","category":"page"},{"location":"connectors/sign_convention/#Hydraulic","page":"Sign Convention","title":"Hydraulic","text":"","category":"section"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"The flow variable (i.e. mass flow) input component for the Hydraulic domain is","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"using ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible\n\n@mtkmodel ConstantMassFlow begin\n    @parameters begin\n        dm\n    end\n    @components begin\n        port = HydraulicPort()\n    end\n    @equations begin\n        port.dm ~ -dm\n    end\nend","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"A positive input mass flow leads to an increasing pressure (in this case we get increasing density (rho), which is directly related to an increasing pressure).","category":"page"},{"location":"connectors/sign_convention/","page":"Sign Convention","title":"Sign Convention","text":"@mtkmodel System begin\n    @components begin\n        volume = FixedVolume(; vol = 10.0)\n        flow = ConstantMassFlow(; dm = 1)\n        fluid = HydraulicFluid()\n    end\n    @equations begin\n        connect(flow.port, volume.port)\n        connect(fluid, flow.port)\n    end\nend\n@mtkbuild sys = System()\nfull_equations(sys) |> first","category":"page"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary:-Magnetic-Components","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary: Magnetic Components","text":"","category":"section"},{"location":"API/magnetic/","page":"Magnetic Components","title":"Magnetic Components","text":"Pages = [\"magnetic.md\"]","category":"page"},{"location":"API/magnetic/#Index","page":"Magnetic Components","title":"Index","text":"","category":"section"},{"location":"API/magnetic/","page":"Magnetic Components","title":"Magnetic Components","text":"Pages = [\"magnetic.md\"]","category":"page"},{"location":"API/magnetic/#Flux-Tubes","page":"Magnetic Components","title":"Flux Tubes","text":"","category":"section"},{"location":"API/magnetic/","page":"Magnetic Components","title":"Magnetic Components","text":"CurrentModule = ModelingToolkitStandardLibrary.Magnetic.FluxTubes","category":"page"},{"location":"API/magnetic/#Flux-Tube-Utilities","page":"Magnetic Components","title":"Flux Tube Utilities","text":"","category":"section"},{"location":"API/magnetic/","page":"Magnetic Components","title":"Magnetic Components","text":"PositiveMagneticPort\nNegativeMagneticPort\nTwoPort","category":"page"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary.Magnetic.FluxTubes.PositiveMagneticPort","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary.Magnetic.FluxTubes.PositiveMagneticPort","text":"Positive magnetic port\n\n\n\n\n\n","category":"constant"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary.Magnetic.FluxTubes.NegativeMagneticPort","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary.Magnetic.FluxTubes.NegativeMagneticPort","text":"Negative magnetic port\n\n\n\n\n\n","category":"constant"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary.Magnetic.FluxTubes.TwoPort","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary.Magnetic.FluxTubes.TwoPort","text":"TwoPort(; name, V_m = 0.0, Phi = 0.0)\n\nPartial component with magnetic potential difference between two magnetic ports p and n and magnetic flux Phi from p to n.\n\nParameters:\n\nV_m: Initial magnetic potential difference between both ports\nPhi: Initial magnetic flux from portp to portn\n\n\n\n\n\n","category":"constant"},{"location":"API/magnetic/#Basic-Flux-Tube-Blocks","page":"Magnetic Components","title":"Basic Flux Tube Blocks","text":"","category":"section"},{"location":"API/magnetic/","page":"Magnetic Components","title":"Magnetic Components","text":"Ground\nIdle\nShort\nCrossing\nConstantPermeance\nConstantReluctance\nEddyCurrent\nElectroMagneticConverter","category":"page"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary.Magnetic.FluxTubes.Ground","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary.Magnetic.FluxTubes.Ground","text":"Ground(; name)\n\nZero magnetic potential.\n\n\n\n\n\n","category":"constant"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary.Magnetic.FluxTubes.Idle","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary.Magnetic.FluxTubes.Idle","text":"Idle(;name)\n\nIdle running branch.\n\n\n\n\n\n","category":"constant"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary.Magnetic.FluxTubes.Short","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary.Magnetic.FluxTubes.Short","text":"Short(;name)\n\nShort cut branch.\n\n\n\n\n\n","category":"constant"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary.Magnetic.FluxTubes.Crossing","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary.Magnetic.FluxTubes.Crossing","text":"Crossing(;name)\n\nCrossing of two branches.\n\nThis is a simple crossing of two branches. The ports portp1 and portp2 are connected, as well as portn1 and portn2.\n\n\n\n\n\n","category":"constant"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary.Magnetic.FluxTubes.ConstantPermeance","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary.Magnetic.FluxTubes.ConstantPermeance","text":"ConstantPermeance(; name, G_m = 1.0)\n\nConstant permeance.\n\nParameters:\n\nG_m: [H] Magnetic permeance\n\n\n\n\n\n","category":"constant"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary.Magnetic.FluxTubes.ConstantReluctance","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary.Magnetic.FluxTubes.ConstantReluctance","text":"ConstantReluctance(; name, R_m = 1.0)\n\nConstant reluctance.\n\nParameters:\n\nR_m: [H^-1] Magnetic reluctance\n\n\n\n\n\n","category":"constant"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary.Magnetic.FluxTubes.EddyCurrent","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary.Magnetic.FluxTubes.EddyCurrent","text":"EddyCurrent(;name, Phi, rho = 0.098e-6, l = 1, A = 1)\n\nFor modelling of eddy current in a conductive magnetic flux tube. Initial magnetic flux flowing into the port_p can be set with Phi ([Wb])\n\nParameters:\n\nrho: [ohm * m] Resistivity of flux tube material (default: Iron at 20degC)\nl: [m] Average length of eddy current path\nA: [m^2] Cross sectional area of eddy current path\n\n\n\n\n\n","category":"constant"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary.Magnetic.FluxTubes.ElectroMagneticConverter","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary.Magnetic.FluxTubes.ElectroMagneticConverter","text":"ElectroMagneticConverter(; name, N, Phi)\n\nIdeal electromagnetic energy conversion.\n\nThe electromagnetic energy conversion is given by Ampere's law and Faraday's law respectively V_m = N * i N * dΦ/dt = -v\n\nInitial magnetic flux flowing into the port_p can be set with Phi ([Wb])\n\nParameters:\n\nN: Number of turns\n\n\n\n\n\n","category":"constant"},{"location":"API/magnetic/#Flux-Tube-Sources","page":"Magnetic Components","title":"Flux Tube Sources","text":"","category":"section"},{"location":"API/magnetic/","page":"Magnetic Components","title":"Magnetic Components","text":"ConstantMagneticPotentialDifference\nConstantMagneticFlux","category":"page"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary.Magnetic.FluxTubes.ConstantMagneticPotentialDifference","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary.Magnetic.FluxTubes.ConstantMagneticPotentialDifference","text":"ConstantMagneticPotentialDifference(; name, V_m = 0.0)\n\nConstant magnetomotive force.\n\nParameters:\n\nV_m: [A] Magnetic potential difference\n\n\n\n\n\n","category":"constant"},{"location":"API/magnetic/#ModelingToolkitStandardLibrary.Magnetic.FluxTubes.ConstantMagneticFlux","page":"Magnetic Components","title":"ModelingToolkitStandardLibrary.Magnetic.FluxTubes.ConstantMagneticFlux","text":"ConstantMagneticFlux(; name, Phi = 0.0)\n\nSource of constant magnetic flux.\n\nParameters:\n\nPhi: [Wb] Magnetic flux\n\n\n\n\n\n","category":"constant"},{"location":"tutorials/thermal_model/#Heat-Conduction-Model","page":"Thermal Conduction Model","title":"Heat Conduction Model","text":"","category":"section"},{"location":"tutorials/thermal_model/","page":"Thermal Conduction Model","title":"Thermal Conduction Model","text":"This example demonstrates the thermal response of two masses connected by a conducting element. The two masses have the same heat capacity but different initial temperatures (T1=100 [°C], T2=0 [°C]). The mass with the higher temperature will cool off, while the mass with the lower temperature heats up. They will each asymptotically approach the calculated temperature TfinalK that results from dividing the total initial energy in the system by the sum of the heat capacities of each element.","category":"page"},{"location":"tutorials/thermal_model/","page":"Thermal Conduction Model","title":"Thermal Conduction Model","text":"using ModelingToolkitStandardLibrary.Thermal, ModelingToolkit, OrdinaryDiffEq, Plots\nusing ModelingToolkit: t_nounits as t\n\n@mtkmodel HeatConductionModel begin\n    @parameters begin\n        C1 = 15\n        C2 = 15\n    end\n    @components begin\n        mass1 = HeatCapacitor(C = C1, T = 373.15)\n        mass2 = HeatCapacitor(C = C2, T = 273.15)\n        conduction = ThermalConductor(G = 10)\n        Tsensor1 = TemperatureSensor()\n        Tsensor2 = TemperatureSensor()\n    end\n    @equations begin\n        connect(mass1.port, conduction.port_a)\n        connect(conduction.port_b, mass2.port)\n        connect(mass1.port, Tsensor1.port)\n        connect(mass2.port, Tsensor2.port)\n    end\nend\n\n@mtkbuild sys = HeatConductionModel()\nprob = ODEProblem(sys, Pair[], (0, 5.0))\nsol = solve(prob)\n\nT_final_K = sol[(sys.mass1.T * sys.C1 + sys.mass2.T * sys.C2) / (sys.C1 + sys.C2)]\n\nplot(title = \"Thermal Conduction Demonstration\")\nplot!(sol, idxs = [sys.mass1.T, sys.mass2.T],\n    labels = [\"Mass 1 Temperature\" \"Mass 2 Temperature\"])\nplot!(sol.t, T_final_K, label = \"Steady-State Temperature\")","category":"page"},{"location":"API/hydraulic/#hydraulic","page":"Hydraulic Components","title":"ModelingToolkit Standard Library: Hydraulic Components","text":"","category":"section"},{"location":"API/hydraulic/","page":"Hydraulic Components","title":"Hydraulic Components","text":"Pages = [\"hydraulic.md\"]\nDepth = 3","category":"page"},{"location":"API/hydraulic/#Index","page":"Hydraulic Components","title":"Index","text":"","category":"section"},{"location":"API/hydraulic/","page":"Hydraulic Components","title":"Hydraulic Components","text":"Pages = [\"hydraulic.md\"]","category":"page"},{"location":"API/hydraulic/#IsothermalCompressible-Components","page":"Hydraulic Components","title":"IsothermalCompressible Components","text":"","category":"section"},{"location":"API/hydraulic/","page":"Hydraulic Components","title":"Hydraulic Components","text":"CurrentModule = ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible","category":"page"},{"location":"API/hydraulic/#IsothermalCompressible-Utils","page":"Hydraulic Components","title":"IsothermalCompressible Utils","text":"","category":"section"},{"location":"API/hydraulic/","page":"Hydraulic Components","title":"Hydraulic Components","text":"HydraulicPort\nHydraulicFluid\nfriction_factor","category":"page"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.HydraulicPort","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.HydraulicPort","text":"HydraulicPort(;p_int, name)\n\nConnector port for hydraulic components.\n\nArguments:\n\np_int: [Pa] initial gauge pressure\n\nStates:\n\np: [Pa] gauge total pressure\ndm: [kg/s] mass flow\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.HydraulicFluid","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.HydraulicFluid","text":"HydraulicFluid(; density = 997, bulk_modulus = 2.09e9, viscosity = 0.0010016, gas_density = 0.0073955, gas_pressure = -1000, n = 1, let_gas = 1, name)\n\nFluid parameter setter for isothermal compressible fluid domain.  Defaults given for water at 20°C and 0Pa gage (1atm absolute) reference pressure. Density is modeled using the Tait equation of state.  For pressures below the reference pressure, density is linearly interpolated to the gas state (when let_gas is set to 1), this helps prevent pressures from going below the reference pressure.  \n\nParameters:\n\nρ: [kg/m^3] fluid density at 0Pa reference gage pressure (set by density argument)\nΒ: [Pa] fluid bulk modulus describing the compressibility (set by bulk_modulus argument)\nμ: [Pa*s] or [kg/m-s] fluid dynamic viscosity  (set by viscosity argument)\nn: density exponent\nlet_gas: set to 1 to allow fluid to transition from liquid to gas (for density calculation only)  \nρ_gas: [kg/m^3] density of fluid in gas state at reference gage pressure p_gas (set by gas_density argument)\np_gas: [Pa] reference pressure (set by gas_pressure argument)\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.friction_factor","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.friction_factor","text":"friction_factor(dm, area, d_h, viscosity, shape_factor)\n\nCalculates the friction factor f for fully developed flow in a tube such that Δp = f cdot rho fracu^22 fracld_h where \n\nΔp: [Pa] is the pressure difference over the tube length l\nrho: [kg/m^3] is the average fluid density\nu: [m/s] is the average fluid velocity\nl: [m] is the tube length \n\nThe friction factor is calculated for laminar and turbulent flow with a transition region between Reynolds number 2000 to 3000.  Turbulent flow equation is for smooth tubes, valid for the Reynolds number range up to 5e6.\n\nArguments:\n\ndm: [kg/s] mass flow\narea: [m^2] tube cross sectional area\nd_h: [m] tube hydraulic diameter.  For circular tubes d_h is the tube diameter, otherwise it can be found from 4*area/perimeter\ndensity: [kg/m^3] fluid density\nviscosity: [Pa*s] or [kg/m-s] fluid dynamic viscosity\nshape_factor: the constant defining the laminar fully developed constant f*Re related to the shape of the tube cross section\n\nReference: Introduction to Fluid Mechanics, Fox & McDonald, 5th Edition, equations 8.19 and 8.21\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#IsothermalCompressible-Components-2","page":"Hydraulic Components","title":"IsothermalCompressible Components","text":"","category":"section"},{"location":"API/hydraulic/","page":"Hydraulic Components","title":"Hydraulic Components","text":"Cap\nOpen\nTubeBase\nTube\nFlowDivider\nValve\nFixedVolume\nVolume\nDynamicVolume\nSpoolValve\nSpoolValve2Way\nActuator","category":"page"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Cap","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Cap","text":"Cap(; p_int, name)\n\nCaps a hydraulic port to prevent mass flow in or out.\n\nParameters:\n\np_int: [Pa] initial pressure (set by p_int argument)\n\nConnectors:\n\nport: hydraulic port\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Open","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Open","text":"Open(; p_int, name)\n\nProvides an \"open\" boundary condition for a hydraulic port such that mass flow dm is non-zero.  This is opposite from an un-connected hydraulic port or the Cap boundary component which sets the mass flow dm to zero.  \n\nParameters:\n\np_int: [Pa] initial pressure (set by p_int argument)\n\nConnectors:\n\nport: hydraulic port\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.TubeBase","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.TubeBase","text":"TubeBase(add_inertia = true; area, length_int, head_factor = 1, perimeter = 2 * sqrt(area * pi), shape_factor = 64, name)\n\nVariable length internal flow model of the fully developed incompressible flow friction.  Includes optional inertia term when add_inertia = true to model wave propagation.  Hydraulic ports have equal flow but variable pressure.  Density is averaged over the pressures, used to calculated average flow velocity and flow friction.\n\nStates:\n\nx: [m] length of the pipe\nddm: [kg/s^2] Rate of change of mass flow rate in control volume.\n\nParameters:\n\narea: [m^2] tube cross sectional area\nlength_int: [m] initial tube length\nperimeter: [m] perimeter of the pipe cross section (needed only for non-circular pipes)\nshape_factor: shape factor, see friction_factor function\nhead_factor: effective length multiplier, used to account for addition friction from flow development and additional friction such as pipe bends, entrance/exit lossses, etc.\n\nConnectors:\n\nport_a: hydraulic port\nport_b: hydraulic port\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Tube","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Tube","text":"Tube(N, add_inertia=true; area, length, head_factor=1, perimeter = 2 * sqrt(area * pi), shape_factor = 64, name)\n\nConstant length internal flow model discretized by N (FixedVolume: N, TubeBase:N-1) which models the fully developed flow friction, compressibility (when N>1), and inertia effects when add_inertia = true.  See TubeBase and FixedVolume for more information.\n\nParameters:\n\narea: [m^2] tube cross sectional area\nlength: [m] real length of the tube\nperimeter: [m] perimeter of the pipe cross section (needed only for non-circular pipes)\nshape_factor: shape factor, see friction_factor function\nhead_factor: effective length multiplier, used to account for addition friction from flow development and additional friction such as pipe bends, entrance/exit lossses, etc.\n\nConnectors:\n\nport_a: hydraulic port\nport_b: hydraulic port\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.FlowDivider","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.FlowDivider","text":"FlowDivider(;p_int, n, name)\n\nReduces the flow from port_a to port_b by n.  Useful for modeling parallel tubes efficiently by placing a FlowDivider on each end of a tube.\n\nParameters:\n\np_int: [Pa] initial pressure\nn: divide flow from port_a to port_b by n\n\nConnectors:\n\nport_a: full flow hydraulic port\nport_b: part flow hydraulic port\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Valve","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Valve","text":"Valve(reversible = false; p_a_int, p_b_int, area_int, Cd, Cd_reverse = Cd, minimum_area = 0, name)\n\nValve with area input and discharge coefficient Cd defined by https://en.wikipedia.org/wiki/Dischargecoefficient.  The `Cdreverse` parameter allows for directional flow restriction, making it possible to define a check valve.\n\nParameters:\n\np_a_int: [Pa] initial pressure for port_a\np_b_int: [Pa] initial pressure for port_b\narea_int: [m^2] initial valve opening\nCd: discharge coefficient flowing from a → b\nCd_reverse: discharge coefficient flowing from b → a\nminimum_area: when reversible = false applies a forced minimum area\n\nConnectors:\n\nport_a: hydraulic port\nport_b: hydraulic port\narea: real input setting the valve area.  When reversible = true, negative input reverses flow direction, otherwise a floor of minimum_area is enforced.\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.FixedVolume","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.FixedVolume","text":"FixedVolume(; vol, name)\n\nFixed fluid volume.\n\nParameters:\n\nvol: [m^3] fixed volume\n\nConnectors:\n\nport: hydraulic port\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Volume","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Volume","text":"Volume(; x, dx=0, p, drho=0, dm=0, area, direction = +1, name)\n\nVolume with moving wall with flange connector for converting hydraulic energy to 1D mechanical.  The direction argument aligns the mechanical port with the hydraulic port, useful when connecting two dynamic volumes together in oppsing directions to create an actuator.\n\n     ┌─────────────────┐ ───\n     │                 │  ▲\n                       │  │\ndm ────►               │  │ area\n                       │  │\n     │                 │  ▼\n     └─────────────────┤ ───\n                       │\n                       └─► x (= ∫ flange.v * direction)\n\nFeatures:\n\nvolume discretization with flow resistance and inertia: use N to control number of volume and resistance elements.  Set N=0 to turn off volume discretization. See TubeBase for more information about flow resistance.\nminimum volume flow shutoff with damping and directional resistance.  Use reversible=false when problem defines volume position x and solves for dm to prevent numerical instability.\n\nParameters:\n\nvolume\n\np: [Pa] initial pressure\narea: [m^2] moving wall area\nx: [m] initial wall position\ndx=0: [m/s] initial wall velocity\ndrho=0: [kg/m^3/s] initial density derivative\ndm=0: [kg/s] initial flow\ndirection: [+/-1] applies the direction conversion from the flange to x\n\nConnectors:\n\nport: hydraulic port\nflange: mechanical translational port\n\nSee also FixedVolume, DynamicVolume\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.DynamicVolume","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.DynamicVolume","text":"DynamicVolume(N, add_inertia=true; p_int,  area, x_int = 0, x_max, x_min = 0, x_damp = x_min, direction = +1, perimeter = 2 * sqrt(area * pi), shape_factor = 64, head_factor = 1, Cd = 1e2, Cd_reverse = Cd, name)\n\nVolume with moving wall with flange connector for converting hydraulic energy to 1D mechanical.  The direction argument aligns the mechanical port with the hydraulic port, useful when connecting two dynamic volumes together in oppsing directions to create an actuator.\n\n     ┌─────────────────┐ ───\n     │                 │  ▲\n                       │  │\ndm ────►               │  │ area\n                       │  │\n     │                 │  ▼\n     └─────────────────┤ ───\n                       │\n                       └─► x (= ∫ flange.v * direction)\n\nFeatures:\n\nvolume discretization with flow resistance and inertia: use N to control number of volume and resistance elements.  Set N=0 to turn off volume discretization. See TubeBase for more information about flow resistance.\nminimum volume flow shutoff with damping and directional resistance.  Use reversible=false when problem defines volume position x and solves for dm to prevent numerical instability.\n\nParameters:\n\nvolume\n\narea: [m^2] moving wall area\nx_max: [m] max wall position, needed for volume discretization to apply the correct volume sizing as a function of x\nx_min: [m] wall position that shuts off flow and prevents negative volume.\nx_damp: [m] wall position that initiates a linear damping region before reaching full flow shut off.  Helps provide a smooth end stop.\ndirection: [+/-1] applies the direction conversion from the flange to x\n\nflow resistance\n\nperimeter: [m] perimeter of the cross section (needed only for non-circular volumes)\nshape_factor: shape factor, see friction_factor function\nhead_factor: effective length multiplier, used to account for addition friction from flow development and additional friction such as pipe bends, entrance/exit lossses, etc.\n\nflow shut off and damping\n\nCd: discharge coefficient for flow out of the volume.  Note: area is 1m² when valve is fully open.  Ensure this does not induce unwanted flow resistance.\nCd_reverse: discharge coefficient for flow into the volume. Use a lower value to allow easy wall release, in some cases the wall can \"stick\".\n\nConnectors:\n\nport: hydraulic port\nflange: mechanical translational port\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.SpoolValve","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.SpoolValve","text":"SpoolValve(reversible = false; p_a_int, p_b_int, x_int, Cd, d, name)\n\nSpool valve with x valve opening input as mechanical flange port and d diameter of orifice. See Valve for more information.\n\nParameters:\n\np_a_int: [Pa] initial pressure for port_a\np_b_int: [Pa] initial pressure for port_b\nx_int: [m] initial valve opening\nd: [m] orifice diameter\nCd: discharge coefficient flowing from a → b\n\nConnectors:\n\nport_a: hydraulic port\nport_b: hydraulic port\nflange: mechanical translational port\n\nSee Valve for more information.\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.SpoolValve2Way","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.SpoolValve2Way","text":"SpoolValve2Way(reversible = false; p_s_int, p_a_int, p_b_int, p_r_int, m, g, x_int, Cd, d, name)\n\n2-ways spool valve with 4 ports and spool mass. Fluid flow direction S → A and B → R when x is positive and S → B and A → R when x is negative. \n\nParameters:\n\np_s_int: [Pa] initial pressure for port_s\np_a_int: [Pa] initial pressure for port_a\np_b_int: [Pa] initial pressure for port_b\np_r_int: [Pa] initial pressure for port_r\nm: [kg] mass of the  spool\ng: [m/s²] gravity field acting on the spool, positive value acts in the positive direction\nx_int: [m] initial valve opening\nd: [m] orifice diameter\nCd: discharge coefficient flowing from s → a and b → r\n\nConnectors:\n\nport_s: hydraulic port\nport_a: hydraulic port\nport_b: hydraulic port\nport_r: hydraulic port\nflange: mechanical translational port\n\nSee SpoolValve for more information.\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Actuator","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Actuator","text":"Actuator(N, add_inertia = true, reversible = false;\n    p_a_int,\n    p_b_int,\n    area_a,\n    area_b,\n    perimeter_a = 2 * sqrt(area_a * pi),\n    perimeter_b = 2 * sqrt(area_b * pi),\n    length_a_int,\n    length_b_int,\n    shape_factor_a = 64,\n    shape_factor_b = 64,\n    head_factor_a = 1,\n    head_factor_b = 1,\n    m,\n    g,\n    x_int = 0,\n    minimum_volume_a = 0,\n    minimum_volume_b = 0,\n    damping_volume_a = minimum_volume_a,\n    damping_volume_b = minimum_volume_b,\n    Cd = 1e4,\n    Cd_reverse = Cd,\n    name)\n\nActuator made of two DynamicVolumes connected in opposite direction with body mass attached.\n\nFeatures:\n\nvolume discretization with flow resistance and inertia: use N to control number of volume and resistance elements.  Set N=0 to turn off volume discretization. See TubeBase for more information about flow resistance.\nminimum volume flow shutoff with damping and directional resistance.  Use reversible=false when problem defines volume position x and solves for dm to prevent numerical instability.\n\nParameters:\n\nvolume\n\np_a_int: [Pa] initial pressure for port_a\np_b_int: [Pa] initial pressure for port_b\narea_a: [m^2] moving wall area of volume A\narea_b: [m^2] moving wall area of volume B\nlength_a_int: [m] initial wall position for A\nlength_b_int: [m] initial wall position for b\n\nmass\n\nm: [kg] mass of the body\ng: [m/s²] gravity field acting on the mass, positive value acts in the positive direction\nx_int: [m] initial flange position\n\nflow resistance\n\nperimeter_a: [m] perimeter of the cross section A (needed only for non-circular volumes)\nperimeter_b: [m] perimeter of the cross section B (needed only for non-circular volumes)\nshape_factor_a: shape factor of A, see friction_factor function\nshape_factor_b: shape factor of B, see friction_factor function\nhead_factor_a: effective length multiplier for A, used to account for addition friction from flow development and additional friction such as pipe bends, entrance/exit lossses, etc.\nhead_factor_b: effective length multiplier for B, used to account for addition friction from flow development and additional friction such as pipe bends, entrance/exit lossses, etc.\n\nflow shut off and damping\n\nminimum_volume_a: [m^3] minimum volume A that shuts off flow and prevents negative volume.\nminimum_volume_b: [m^3] minimum volume B that shuts off flow and prevents negative volume.\ndamping_volume_a: [m^3] volume of A that initiates a linear damping region before reaching full flow shut off.  Helps provide a smooth end stop.\ndamping_volume_b: [m^3] volume of B that initiates a linear damping region before reaching full flow shut off.  Helps provide a smooth end stop.\nCd: discharge coefficient for flow out of the volume.  Note: area is 1m² when valve is fully open.  Ensure this does not induce unwanted flow resistance.\nCd_reverse: discharge coefficient for flow into the volume. Use a lower value to allow easy wall release, in some cases the wall can \"stick\".\n\nConnectors:\n\nport_a: hydraulic port\nport_b: hydraulic port\nflange: mechanical translational port\n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#IsothermalCompressible-Sources","page":"Hydraulic Components","title":"IsothermalCompressible Sources","text":"","category":"section"},{"location":"API/hydraulic/","page":"Hydraulic Components","title":"Hydraulic Components","text":"MassFlow\nPressure\nFixedPressure","category":"page"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.MassFlow","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.MassFlow","text":"MassFlow(; name, p_int)\n\nHydraulic mass flow input source\n\nConnectors:\n\nport: hydraulic port\ndm: real input \n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Pressure","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.Pressure","text":"Pressure(; name)\n\ninput pressure source\n\nConnectors:\n\nport: hydraulic port\np: real input \n\n\n\n\n\n","category":"function"},{"location":"API/hydraulic/#ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.FixedPressure","page":"Hydraulic Components","title":"ModelingToolkitStandardLibrary.Hydraulic.IsothermalCompressible.FixedPressure","text":"FixedPressure(; p, name)\n\nFixed pressure source\n\nParameters:\n\np: [Pa] set pressure (set by p argument)\n\nConnectors:\n\nport: hydraulic port\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary:-Blocks","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary: Blocks","text":"","category":"section"},{"location":"API/blocks/","page":"Basic Blocks","title":"Basic Blocks","text":"CurrentModule = ModelingToolkitStandardLibrary.Blocks","category":"page"},{"location":"API/blocks/","page":"Basic Blocks","title":"Basic Blocks","text":"Pages = [\"blocks.md\"]","category":"page"},{"location":"API/blocks/#Index","page":"Basic Blocks","title":"Index","text":"","category":"section"},{"location":"API/blocks/","page":"Basic Blocks","title":"Basic Blocks","text":"Pages = [\"blocks.md\"]","category":"page"},{"location":"API/blocks/#Utility-Blocks","page":"Basic Blocks","title":"Utility Blocks","text":"","category":"section"},{"location":"API/blocks/","page":"Basic Blocks","title":"Basic Blocks","text":"RealInput\nRealOutput\nRealInputArray\nRealOutputArray\nSISO\nMIMO","category":"page"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.RealInput","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.RealInput","text":"RealInput(;name, guess)\n\nConnector with one input signal of type Real.\n\nParameters:\n\nguess=0: Guess value for u.\n\nStates:\n\nu: Value of the connector which is a scalar.\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.RealOutput","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.RealOutput","text":"RealOutput(;name, guess)\n\nConnector with one output signal of type Real.\n\nParameters:\n\nguess=0: Guess value for u.\n\nStates:\n\nu: Value of the connector which is a scalar.\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.RealInputArray","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.RealInputArray","text":"RealInputArray(;name, nin, guess)\n\nConnector with an array of input signals of type Real.\n\nParameters:\n\nnin: Number of inputs.\nguess=zeros(nin): Guess value for u.\n\nStates:\n\nu: Value of the connector which is an array.\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.RealOutputArray","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.RealOutputArray","text":"RealOutputArray(;name, nout, guess)\n\nConnector with an array of output signals of type Real.\n\nParameters:\n\nnout: Number of outputs.\nguess=zeros(nout): Guess value for u.\n\nStates:\n\nu: Value of the connector which is an array.\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.SISO","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.SISO","text":"SISO(;name, u_start = 0.0, y_start = 0.0)\n\nSingle input single output (SISO) continuous system block.\n\nParameters:\n\nu_start: Initial value for the input\ny_start: Initial value for the output\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.MIMO","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.MIMO","text":"MIMO(; name, nin = 1, nout = 1, u_start = zeros(nin), y_start = zeros(nout))\n\nBase class for a multiple input multiple output (MIMO) continuous system block.\n\nParameters:\n\nnin: Input dimension\nnout: Output dimension\nu_start: Initial value for the input\ny_start: Initial value for the output\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#Math-Blocks","page":"Basic Blocks","title":"Math Blocks","text":"","category":"section"},{"location":"API/blocks/","page":"Basic Blocks","title":"Basic Blocks","text":"Gain\nMatrixGain\nSum\nFeedback\nAdd\nAdd3\nProduct\nDivision\nStaticNonLinearity\nAbs\nSign\nSqrt\nSin\nCos\nTan\nAsin\nAcos\nAtan\nAtan2\nSinh\nCosh\nTanh\nExp\nLog\nLog10","category":"page"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Gain","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Gain","text":"Gain(; name, k)\n\nOutput the product of a gain value with the input signal.\n\nParameters:\n\nk: Scalar gain\n\nConnectors:\n\ninput\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.MatrixGain","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.MatrixGain","text":"MatrixGain(; K::AbstractArray, name)\n\nOutput the product of a gain matrix with the input signal vector.\n\nStructural parameters:\n\nK: Matrix gain\n\nConnectors:\n\ninput\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Sum","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Sum","text":"Sum(; input__nin::Int, name)\n\nOutput the sum of the elements of the input port vector. Input port dimension can be set with input__nin\n\nConnectors:\n\ninput\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Feedback","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Feedback","text":"Feedback(; name)\n\nOutput difference between reference input (input1) and feedback input (input2).\n\nConnectors:\n\ninput1\ninput2\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Add","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Add","text":"Add(; name, k1 = 1.0, k2 = 1.0)\n\nOutput the sum of the two scalar inputs.\n\nParameters:\n\nk1: Gain for first input\nk2: Gain for second input\n\nConnectors:\n\ninput1\ninput2\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Add3","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Add3","text":"Add(; name, k1 = 1.0, k2 = 1.0, k3 = 1.0)\n\nOutput the sum of the three scalar inputs.\n\nParameters:\n\nk1: Gain for first input\nk2: Gain for second input\nk3: Gain for third input\n\nConnectors:\n\ninput1\ninput2\ninput3\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Product","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Product","text":"Product(; name)\n\nOutput product of the two inputs.\n\nConnectors:\n\ninput1\ninput2\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Division","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Division","text":"Division(; name)\n\nOutput first input divided by second input.\n\nConnectors:\n\ninput1\ninput2\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.StaticNonLinearity","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.StaticNonLinearity","text":"StaticNonLinearity(func; name)\n\nApplies the given function to the input.\n\nIf the given function is not composed of simple core methods (e.g. sin, abs, ...), it has to be registered via @register_symbolic func(u)\n\nConnectors:\n\ninput\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Abs","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Abs","text":"Abs(; name)\n\nOutput the absolute value of the input.\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Sign","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Sign","text":"Sign(; name)\n\nOutput the sign of the input\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Sqrt","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Sqrt","text":"Sqrt(; name)\n\nOutput the square root of the input (input >= 0 required).\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Sin","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Sin","text":"Sin(; name)\n\nOutput the sine of the input.\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Cos","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Cos","text":"Cos(; name)\n\nOutput the cosine of the input.\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Tan","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Tan","text":"Tan(; name)\n\nOutput the tangent of the input.\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Asin","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Asin","text":"Asin(; name)\n\nOutput the arc sine of the input.\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Acos","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Acos","text":"Acos(; name)\n\nOutput the arc cosine of the input.\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Atan","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Atan","text":"Atan(; name)\n\nOutput the arc tangent of the input.\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Atan2","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Atan2","text":"Atan2(; name)\n\nOutput the arc tangent of the input.\n\nConnectors:\n\ninput1\ninput2\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Sinh","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Sinh","text":"Sinh(; name)\n\nOutput the hyperbolic sine of the input.\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Cosh","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Cosh","text":"Cosh(; name)\n\nOutput the hyperbolic cosine of the input.\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Tanh","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Tanh","text":"Tanh(; name)\n\nOutput the hyperbolic tangent of the input.\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Exp","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Exp","text":"Exp(; name)\n\nOutput the exponential (base e) of the input.\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Log","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Log","text":"Log(; name)\n\nOutput the natural (base e) logarithm of the input.\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Log10","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Log10","text":"Log10(; name)\n\nOutput the base 10 logarithm of the input.\n\nConnectors:\n\nSee StaticNonLinearity\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#Source-Blocks","page":"Basic Blocks","title":"Source Blocks","text":"","category":"section"},{"location":"API/blocks/","page":"Basic Blocks","title":"Basic Blocks","text":"Constant\nSine\nCosine\nContinuousClock\nRamp\nStep\nExpSine","category":"page"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Constant","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Constant","text":"Constant(; name, k = 0.0)\n\nGenerate constant signal.\n\nParameters:\n\nk: Constant output value\n\nConnectors:\n\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Sine","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Sine","text":"Sine(; name, frequency, amplitude = 1, phase = 0, offset = 0, start_time = 0,\nsmooth = false)\n\nGenerate sine signal.\n\nParameters:\n\nfrequency: [Hz] Frequency of sine wave\namplitude: Amplitude of sine wave\nphase: [rad] Phase of sine wave\noffset: Offset of output signal\nstart_time: [s] Output y = offset for t < start_time\nsmooth:  If true, returns a smooth wave. Defaults to false It uses a default smoothing factor of δ=1e-5, but this can be changed by supplying smooth=δ.\n\nConnectors:\n\noutput\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Cosine","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Cosine","text":"Cosine(; name, frequency, amplitude = 1, phase = 0, offset = 0, start_time = 0,\nsmooth = false)\n\nGenerate cosine signal.\n\nParameters:\n\nfrequency: [Hz] Frequency of cosine wave\namplitude: Amplitude of cosine wave\nphase: [rad] Phase of cosine wave\noffset: Offset of output signal\nstart_time: [s] Output y = offset for t < start_time\nsmooth:  If true, returns a smooth wave. Defaults to false            It uses a default smoothing factor of δ=1e-5, but this can be changed by supplying smooth=δ.\n\nConnectors:\n\noutput\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.ContinuousClock","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.ContinuousClock","text":"ContinuousClock(; name, offset = 0, start_time = 0)\n\nGenerate current time signal.\n\nParameters:\n\noffset: Offset of output signal\nstart_time: [s] Output y = offset for t < start_time\n\nConnectors:\n\noutput\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Ramp","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Ramp","text":"Ramp(; name, height = 1, duration = 1, offset = 0, start_time = 0, smooth = false)\n\nGenerate ramp signal.\n\nParameters:\n\nheight: Height of ramp\nduration: [s] Duration of ramp (= 0.0 gives a Step)\noffset: Offset of output signal\nstart_time: [s] Output y = offset for t < start_time\nsmooth:  If true, returns a smooth wave. Defaults to false It uses a default smoothing factor of δ=1e-5, but this can be changed by supplying smooth=δ.\n\nConnectors:\n\noutput\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Step","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Step","text":"Step(;name, height=1, offset=0, start_time=0, duration=Inf, smooth=true)\n\nGenerate step signal.\n\nParameters:\n\nheight: Height of step\noffset: Offset of output signal\nstart_time: [s] Output y = offset for t < start_time and thereafter offset+height.\nduration: [s] If duration < Inf is supplied, the output will revert to offset after duration seconds.\nsmooth:  If true, returns a smooth wave. Defaults to true It uses a default smoothing factor of δ=1e-5, but this can be changed by supplying smooth=δ.\n\nConnectors:\n\noutput\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.ExpSine","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.ExpSine","text":"ExpSine(; name, frequency, amplitude = 1, damping = 0.1, phase = 0, offset = 0, start_time = 0, smooth = false)\n\nExponentially damped sine signal.\n\nParameters:\n\nfrequency: [Hz] Frequency of sine wave\namplitude: Amplitude of sine wave\ndamping: [1/s] Damping coefficient of sine wave\nphase: [rad] Phase of sine wave\noffset: Offset of output signal\nstart_time: [s] Output y = offset for t < start_time\nsmooth:  If true, returns a smooth wave. Defaults to false It uses a default smoothing factor of δ=1e-5, but this can be changed by supplying smooth=δ.\n\nConnectors:\n\noutput\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#Nonlinear-Blocks","page":"Basic Blocks","title":"Nonlinear Blocks","text":"","category":"section"},{"location":"API/blocks/","page":"Basic Blocks","title":"Basic Blocks","text":"Limiter\nDeadZone\nSlewRateLimiter","category":"page"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Limiter","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Limiter","text":"Limiter(;name, y_max, y_min = y_max > 0 ? -y_max : -Inf)\n\nLimit the range of a signal.\n\nParameters:\n\ny_max: Maximum of output signal\ny_min: Minimum of output signal\n\nConnectors:\n\ninput\noutput\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.DeadZone","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.DeadZone","text":"DeadZone(; name, u_max, u_min = -u_max)\n\nThe DeadZone block defines a region of zero output. If the input is within u_min ... u_max, the output is zero. Outside of this zone, the output is a linear function of the input with a slope of 1.\n\n       y▲\n        │     /\n        │    /\n  u_min │   /\n─────|──┼──|───────► u\n    /   │   u_max\n   /    │\n  /     │\n\nParameters:\n\nu_max: Upper limit of dead zone\nu_min: Lower limit of dead zone\n\nConnectors:\n\ninput\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.SlewRateLimiter","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.SlewRateLimiter","text":"SlewRateLimiter(; name, y_start, rising = 1.0, falling = -rising, Td = 0.001)\n\nLimits the slew rate of a signal. Initial value of state Y can be set with int.y\n\nParameters:\n\nrising: Maximum rising slew rate\nfalling: Maximum falling slew rate\nTd: [s] Derivative time constant\ny_start: Initial value of y state of SISO\n\nConnectors:\n\ninput\noutput\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#Continuous-Blocks","page":"Basic Blocks","title":"Continuous Blocks","text":"","category":"section"},{"location":"API/blocks/","page":"Basic Blocks","title":"Basic Blocks","text":"Integrator\nDerivative\nFirstOrder\nSecondOrder\nStateSpace\nTransferFunction\nPI\nLimPI\nPID\nLimPID","category":"page"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Integrator","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Integrator","text":"Integrator(;name, k = 1, x = 0.0)\n\nOutputs y = ∫k*u dt, corresponding to the transfer function 1s. Initial value of integrator state x can be set with x\n\nConnectors:\n\ninput\noutput\n\nParameters:\n\nk: Gain of integrator\n\nUnknowns:\n\nx: State of Integrator. Defaults to 0.0.\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.Derivative","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.Derivative","text":"Derivative(; name, k = 1, T, x = 0.0)\n\nOutputs an approximate derivative of the input. The transfer function of this block is\n\nk      k        ks  \n─ - ─────── = ────── \nT   sT² + T   sT + 1\n\nand a state-space realization is given by ss(-1/T, 1/T, -k/T, k/T) where T is the time constant of the filter. A smaller T leads to a more ideal approximation of the derivative.\n\nInitial value of the state x can be set with x.\n\nParameters:\n\nk: Gain\nT: [s] Time constant (T>0 required; T=0 is ideal derivative block)\n\nUnknowns:\n\nx: Unknown of Derivative. Defaults to 0.0.\n\nConnectors:\n\ninput\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.FirstOrder","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.FirstOrder","text":"FirstOrder(; name, k = 1.0, T, x = 0.0, lowpass = true)\n\nA first-order filter with a single real pole at s = -1/T and gain k. If lowpass=true (default), the transfer function is given by Y(s)U(s) =\n\n   k\n───────\nsT + 1\n\nand if lowpass=false, by\n\nsT + 1 - k\n──────────\n  sT + 1\n\nInitial value of the state x can be set with x\n\nParameters:\n\nk: Gain\nT: [s] Time constant (T>0 required)\n\nConnectors:\n\ninput\noutput\n\nSee also SecondOrder\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.SecondOrder","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.SecondOrder","text":"SecondOrder(; name, k = 1.0, w = 1.0, d = 1.0, x = 0.0, xd = 0.0)\n\nA second-order filter with gain k, a bandwidth of w rad/s and relative damping d. The transfer function is given by Y(s)/U(s) =\n\n      k*w^2\n─────────────────\ns² + 2d*w*s + w^2\n\nCritical damping corresponds to d=1, which yields the fastest step response without overshoot, d < 1 results in an underdamped filter while d > 1 results in an overdamped filter. d = 1/√2 corresponds to a Butterworth filter of order 2 (maximally flat frequency response). Initial value of the state x can be set with x, and of derivative state xd with xd.\n\nParameters:\n\nk: Gain\nw: [rad/s] Angular frequency\nd: Damping\n\nConnectors:\n\ninput\noutput\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.StateSpace","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.StateSpace","text":"StateSpace(A, B, C, D = 0; x = zeros(size(A,1)), u0 = zeros(size(B,2)), y0 = zeros(size(C,1)), name)\n\nA linear, time-invariant state-space system on the form.\n\nbeginaligned\nx = Ax + Bu \ny = Cx + Du\nendaligned\n\nTransfer functions can also be simulated by converting them to a StateSpace form.\n\ny0 and u0 can be used to set an operating point, providing them changes the dynamics from an LTI system to the affine system\n\nbeginaligned\nx = Ax + B(u - u0) \ny = Cx + D(u - u0) + y0\nendaligned\n\nFor a nonlinear system\n\nbeginaligned\nx = f(x u) \ny = h(x u)\nendaligned\n\nlinearized around the operating point x₀, u₀, we have y0, u0 = h(x₀, u₀), u₀.\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.TransferFunction","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.TransferFunction","text":"TransferFunction(; b, a, name)\n\nA single input, single output, linear time-invariant system provided as a transfer-function.\n\nY(s) = b(s) / a(s)  U(s)\n\nwhere b and a are vectors of coefficients of the numerator and denominator polynomials, respectively, ordered such that the coefficient of the highest power of s is first.\n\nThe internal state realization is on controller canonical form, with state variable x, output variable y and input variable u. For numerical robustness, the realization used by the integrator is scaled by the last entry of the a parameter. The internally scaled state variable is available as x_scaled.\n\nTo set the initial state, it's recommended to set the initial condition for x, and let that of x_scaled be computed automatically.\n\nParameters:\n\nb: Numerator polynomial coefficients, e.g., 2s + 3 is specified as [2, 3]\na: Denominator polynomial coefficients, e.g., s² + 2ωs + ω^2 is specified as [1, 2ω, ω^2]\n\nConnectors:\n\ninput\noutput\n\nSee also StateSpace which handles MIMO systems, as well as ControlSystemsMTK.jl for an interface between ControlSystems.jl and ModelingToolkit.jl for advanced manipulation of transfer functions and linear statespace systems. For linearization, see linearize and Linear Analysis.\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.PI","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.PI","text":"PI(;name, k = 1.0, T = 1.0, int.x = 0.0)\n\nTextbook version of a PI-controller without actuator saturation and anti-windup measure. The proportional gain can be set with k Initial value of integrator state x can be set with int.x\n\nThe PI controller is implemented on standard form:\n\nU(s) = k (1 + dfrac1sT) E(S)\n\nParameters:\n\nk: Proportional gain\nT: [s] Integrator time constant (T>0 required)\n\nConnectors:\n\nerr_input\nctr_output\n\nSee also LimPI\n\n\n\n\n\n","category":"constant"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.LimPI","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.LimPI","text":"LimPI(; name, k = 1.0, T, Ta, int__x = 0.0, u_max = 1.0, u_min = -u_max)\n\nText-book version of a PI-controller with actuator saturation and anti-windup measure.\n\nThe PI controller is implemented on standard form\n\nu(t) = sat(k (e(t) + dfrac1Te(t) dt) )\n\nThe simplified expression above is given without the anti-windup protection.\n\nParameters:\n\nk: Proportional gain\nT: [s] Integrator time constant (T>0 required)\nTa: [s] Tracking time constant (Ta>0 required)\n\nConnectors:\n\nerr_input\nctr_output\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.PID","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.PID","text":"PID(;name, k=1, Ti=false, Td=false, Nd=10, int__x=0, der__x=0)\n\nText-book version of a PID-controller without actuator saturation and anti-windup measure.\n\nParameters:\n\nk: Gain\nTi: [s] Integrator time constant (Ti>0 required). If set to false, no integral action is used.\nTd: [s] Derivative time constant (Td>0 required). If set to false, no derivative action is used.\nNd: [s] Time constant for the derivative approximation (Nd>0 required; Nd=0 is ideal derivative).\nint__x: Initial value for the integrator.\nder__x: Initial value for the derivative state.\n\nConnectors:\n\nerr_input\nctr_output\n\nSee also LimPID\n\n\n\n\n\n","category":"function"},{"location":"API/blocks/#ModelingToolkitStandardLibrary.Blocks.LimPID","page":"Basic Blocks","title":"ModelingToolkitStandardLibrary.Blocks.LimPID","text":"LimPID(; k, Ti=false, Td=false, wp=1, wd=1, Ni, Nd=12, u_max=Inf, u_min=-u_max, gains = false, name)\n\nProportional-Integral-Derivative (PID) controller with output saturation, set-point weighting and integrator anti-windup.\n\nThe equation for the control signal is roughly\n\nk(ep + 1/Ti * ∫e + Td * d/dt(ed))\ne = u_r - u_y\nep = wp*u_r - u_y\ned = wd*u_r - u_y\n\nwhere the transfer function for the derivative includes additional filtering, see ? Derivative for more details.\n\nParameters:\n\nk: Proportional gain\nTi: [s] Integrator time constant. Set to false to turn off integral action.\nTd: [s] Derivative time constant. Set to false to turn off derivative action.\nwp: [0,1] Set-point weighting in the proportional part.\nwd: [0,1] Set-point weighting in the derivative part.\nNd: [1/s] Derivative limit, limits the derivative gain to Nd/Td. Reasonable values are ∈ [8, 20]. A higher value gives a better approximation of an ideal derivative at the expense of higher noise amplification.\nNi: Ni*Ti controls the time constant Ta of anti-windup tracking. A common (default) choice is Ta = √(Ti*Td) which is realized by Ni = √(Td / Ti). Anti-windup can be effectively turned off by setting Ni = Inf.\ngains: If gains = true, Ti and Td will be interpreted as gains with a fundamental PID transfer function on parallel form ki=Ti, kd=Td, k + ki/s + kd*s.\n\nConnectors:\n\nreference\nmeasurement\nctr_output\n\n\n\n\n\n","category":"function"},{"location":"API/thermal/#ModelingToolkitStandardLibrary:-Thermal-Components","page":"Thermal Components","title":"ModelingToolkitStandardLibrary: Thermal Components","text":"","category":"section"},{"location":"API/thermal/","page":"Thermal Components","title":"Thermal Components","text":"CurrentModule = ModelingToolkitStandardLibrary.Thermal","category":"page"},{"location":"API/thermal/","page":"Thermal Components","title":"Thermal Components","text":"Pages = [\"thermal.md\"]","category":"page"},{"location":"API/thermal/#Index","page":"Thermal Components","title":"Index","text":"","category":"section"},{"location":"API/thermal/","page":"Thermal Components","title":"Thermal Components","text":"Pages = [\"thermal.md\"]","category":"page"},{"location":"API/thermal/#Thermal-Utilities","page":"Thermal Components","title":"Thermal Utilities","text":"","category":"section"},{"location":"API/thermal/","page":"Thermal Components","title":"Thermal Components","text":"HeatPort\nElement1D","category":"page"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.HeatPort","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.HeatPort","text":"HeatPort(; T = nothing, T_guess = 273.15 + 20, Q_flow = nothing, Q_flow_guess = 0.0, name)\n\nPort for a thermal system.\n\nParameters:\n\nT_guess: [K] Initial guess for the temperature of the port (set to 273.15 + 20).\nQ_flow_guess: [W] Initial guess for the heat flow rate at the port (set to 0.0).\n\nStates:\n\nT: [K] Temperature of the port. Guess set to T_guess. Passing a value for T will set its default.\nQ_flow: [W] Heat flow rate at the port. Guess set to Q_flow_guess. Passing a value for Q_flow will set its default.\n\n\n\n\n\n","category":"function"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.Element1D","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.Element1D","text":"Element1D(; name, dT = 0.0, Q_flow = 0.0)\n\nThis partial model contains the basic connectors and variables to allow heat transfer models to be created that do not store energy. This model defines and includes equations for the temperature drop across the element, dT, and the heat flow rate through the element from port_a to port_b, Q_flow.\n\nStates:\n\ndT:  [K] Temperature difference across the component a.T - b.T. It accepts an initial value, which defaults to 0.0.\nQ_flow: [W] Heat flow rate from port a -> port b. It accepts an initial value, which defaults to 0.0.\n\nConnectors:\n\nport_a port_b\n\n\n\n\n\n","category":"constant"},{"location":"API/thermal/#Thermal-Components","page":"Thermal Components","title":"Thermal Components","text":"","category":"section"},{"location":"API/thermal/","page":"Thermal Components","title":"Thermal Components","text":"BodyRadiation\nConvectiveConductor\nConvectiveResistor\nHeatCapacitor\nThermalConductor\nThermalResistor\nThermalCollector","category":"page"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.BodyRadiation","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.BodyRadiation","text":"BodyRadiation(; name, G)\n\nLumped thermal element for radiation heat transfer.\n\nStates:\n\ndT:  [K] Temperature difference across the component a.T - b.T\nQ_flow: [W] Heat flow rate from port a -> port b\n\nConnectors:\n\nport_a\nport_b\n\nParameters:\n\nG: [m^2] Net radiation conductance between two surfaces # Stefan-Boltzmann constant TODO: extract into physical constants module or use existing one\n\n\n\n\n\n","category":"constant"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.ConvectiveConductor","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.ConvectiveConductor","text":"ConvectiveConductor(; name, G)\n\nLumped thermal element for heat convection.\n\nStates:\n\ndT:  [K] Temperature difference across the component solid.T - fluid.T\nQ_flow: [W] Heat flow rate from solid -> fluid\n\nConnectors:\n\nsolid\nfluid\n\nParameters:\n\nG: [W/K] Convective thermal conductance\n\n\n\n\n\n","category":"constant"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.ConvectiveResistor","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.ConvectiveResistor","text":"ConvectiveResistor(; name, R)\n\nLumped thermal element for heat convection.\n\nStates:\n\ndT: [K] Temperature difference across the component solid.T - fluid.T\nQ_flow: [W] Heat flow rate from solid -> fluid\n\nConnectors:\n\nsolid\nfluid\n\nParameters:\n\nR: [K/W] Constant thermal resistance of material\n\n\n\n\n\n","category":"constant"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.HeatCapacitor","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.HeatCapacitor","text":"HeatCapacitor(; name, C, T = 273.15 + 20)\n\nLumped thermal element storing heat\n\nStates:\n\nT: [K] Temperature of element. It accepts an initial value, which defaults to 273.15 + 20.\nder_T: [K/s] Time derivative of temperature\n\nConnectors:\n\nport\n\nParameters:\n\nC: [J/K] Heat capacity of element (= cp*m)\n\n\n\n\n\n","category":"constant"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.ThermalConductor","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.ThermalConductor","text":"ThermalConductor(; name, G)\n\nLumped thermal element transporting heat without storing it.\n\nStates:\n\nsee Element1D\n\nConnectors:\n\nport_a port_b\n\nParameters:\n\nG: [W/K] Constant thermal conductance of material\n\n\n\n\n\n","category":"constant"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.ThermalResistor","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.ThermalResistor","text":"ThermalResistor(; name, R)\n\nLumped thermal element transporting heat without storing it.\n\nStates:\n\ndT:  [K] Temperature difference across the component a.T - b.T\nQ_flow: [W] Heat flow rate from port a -> port b\n\nConnectors:\n\nport_a\nport_b\n\nParameters:\n\nR: [K/W] Constant thermal resistance of material\n\n\n\n\n\n","category":"constant"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.ThermalCollector","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.ThermalCollector","text":"ThermalCollector(; name, m = 1)\n\nCollects m heat flows\n\nThis is a model to collect the heat flows from m heatports to one single heatport.\n\nStates:\n\nConnectors:\n\nport_a1 to port_am\nport_b\n\nParameters:\n\nm: Number of heat ports (e.g. m=2: port_a1, port_a2)\n\n\n\n\n\n","category":"function"},{"location":"API/thermal/#Thermal-Sensors","page":"Thermal Components","title":"Thermal Sensors","text":"","category":"section"},{"location":"API/thermal/","page":"Thermal Components","title":"Thermal Components","text":"RelativeTemperatureSensor\nHeatFlowSensor\nTemperatureSensor","category":"page"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.RelativeTemperatureSensor","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.RelativeTemperatureSensor","text":"RelativeTemperatureSensor(; name)\n\nRelative Temperature sensor.\n\nThe relative temperature port_a.T - port_b.T is determined between the two ports of this component and is provided as output signal in kelvin.\n\nStates:\n\nT(t): [K] Relative temperature a.T - b.T\n\nConnectors:\n\nport_a\nport_b\n\n\n\n\n\n","category":"constant"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.HeatFlowSensor","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.HeatFlowSensor","text":"HeatFlowSensor(; name)\n\nHeat flow rate sensor.\n\nThis model is capable of monitoring the heat flow rate flowing through this component. The sensed value of heat flow rate is the amount that passes through this sensor while keeping the temperature drop across the sensor zero. This is an ideal model, so it does not absorb any energy, and it has no direct effect on the thermal response of a system it is included in. The output signal is positive, if the heat flows from port_a to port_b.\n\nStates:\n\nQ_flow(t): [W] Heat flow from port_a to port_b\n\nConnectors:\n\nport_a\nport_b\n\n\n\n\n\n","category":"constant"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.TemperatureSensor","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.TemperatureSensor","text":"TemperatureSensor(; name)\n\nAbsolute temperature sensor in kelvin.\n\nThis is an ideal absolute temperature sensor which returns the temperature of the connected port in kelvin as an output signal. The sensor itself has no thermal interaction with whatever it is connected to. Furthermore, no thermocouple-like lags are associated with this sensor model.\n\nStates:\n\nT(t): [K] Absolute temperature\n\nConnectors:\n\nport\n\n\n\n\n\n","category":"constant"},{"location":"API/thermal/#Thermal-Sources","page":"Thermal Components","title":"Thermal Sources","text":"","category":"section"},{"location":"API/thermal/","page":"Thermal Components","title":"Thermal Components","text":"FixedHeatFlow\nFixedTemperature\nPrescribedHeatFlow\nPrescribedTemperature  ","category":"page"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.FixedHeatFlow","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.FixedHeatFlow","text":"FixedHeatFlow(; name, Q_flow = 1.0, T_ref = 293.15, alpha = 0.0)\n\nFixed heat flow boundary condition.\n\nThis model allows a specified amount of heat flow rate to be \"injected\" into a thermal system at a given port. The constant amount of heat flow rate Q_flow is given as a parameter. The heat flows into the component to which the component FixedHeatFlow is connected, if parameter Q_flow is positive.\n\nConnectors:\n\nport\n\nParameters:\n\nQ_flow: [W] Fixed heat flow rate at port\nT_ref: [K] Reference temperature\nalpha: [1/K] Temperature coefficient of heat flow rate\n\n\n\n\n\n","category":"constant"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.FixedTemperature","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.FixedTemperature","text":"FixedTemperature(; name, T)\n\nFixed temperature boundary condition in kelvin.\n\nThis model defines a fixed temperature T at its port in kelvin, i.e., it defines a fixed temperature as a boundary condition.\n\nConnectors:\n\nport\n\nParameters:\n\nT: [K] Fixed temperature boundary condition\n\n\n\n\n\n","category":"constant"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.PrescribedHeatFlow","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.PrescribedHeatFlow","text":"PrescribedHeatFlow(; name, T_ref = 293.15, alpha = 0.0)\n\nPrescribed heat flow boundary condition.\n\nThis model allows a specified amount of heat flow rate to be \"injected\" into a thermal system at a given port. The amount of heat is given by the input signal Q_flow into the model. The heat flows into the component to which the component PrescribedHeatFlow is connected, if the input signal is positive. If parameter alpha is > 0, the heat flow is multiplied by 1 + alpha*(port.T - T_ref) in order to simulate temperature dependent losses (which are given a reference temperature T_ref).\n\nConnectors:\n\nport\nRealInput Q_flow Input for the heat flow\n\nParameters:\n\nT_ref: [K] Reference temperature\nalpha: [1/K] Temperature coefficient of heat flow rate\n\n\n\n\n\n","category":"constant"},{"location":"API/thermal/#ModelingToolkitStandardLibrary.Thermal.PrescribedTemperature","page":"Thermal Components","title":"ModelingToolkitStandardLibrary.Thermal.PrescribedTemperature","text":"PrescribedTemperature(; name)\n\nThis model represents a variable temperature boundary condition.\n\nThe temperature in kelvin is given as input signal to the RealInput T. The effect is that an instance of this model acts as an infinite reservoir, able to absorb or generate as much energy as required to keep the temperature at the specified value.\n\nConnectors:\n\nport\nRealInput T input for the temperature\n\n\n\n\n\n","category":"constant"},{"location":"tutorials/dc_motor_pi/#DC-Motor-with-PI-controller","page":"DC Motor with Speed Controller","title":"DC Motor with PI-controller","text":"","category":"section"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"In this example, a PI-controller is set up for speed control of a DC-motor. An equivalent circuit diagram is depicted below.","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"(Image: DC-motor)","category":"page"},{"location":"tutorials/dc_motor_pi/#Modeling-and-simulation","page":"DC Motor with Speed Controller","title":"Modeling and simulation","text":"","category":"section"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"The electrical part consists of a resistance and inductance. The coupling between the electrical and rotational domain is done via an electro-motive force (EMF) component. The voltage across the EMF is proportional to the angular velocity and the current is proportional to the torque. On the mechanical side, viscous friction in, e.g., a bearing and the inertia of the shaft is modelled.","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"A PI-controller with anti-windup measure should be used as a speed controller. A simulation is performed to verify the tracking performance of the controller and the disturbance rejection capabilities.","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"First, the needed packages are imported and the parameters of the model defined.","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t\nusing ModelingToolkitStandardLibrary.Electrical\nusing ModelingToolkitStandardLibrary.Mechanical.Rotational\nusing ModelingToolkitStandardLibrary.Blocks\nusing OrdinaryDiffEq\nusing Plots","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"The actual model can now be composed.","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"@mtkmodel DCMotor begin\n    @parameters begin\n        R = 0.5, [description = \"Armature resistance\"] # Ohm\n        L = 4.5e-3, [description = \"Armature inductance\"] # H\n        k = 0.5, [description = \"Motor constant\"] # N.m/A\n        J = 0.02, [description = \"Inertia\"] # kg.m²\n        f = 0.01, [description = \"Friction factor\"] # N.m.s/rad\n        tau_L_step = -0.3, [description = \"Amplitude of the load torque step\"] # N.m\n    end\n    @components begin\n        ground = Ground()\n        source = Voltage()\n        ref = Blocks.Step(height = 1, start_time = 0)\n        pi_controller = Blocks.LimPI(k = 1.1, T = 0.035, u_max = 10, Ta = 0.035)\n        feedback = Blocks.Feedback()\n        R1 = Resistor(R = R)\n        L1 = Inductor(L = L)\n        emf = EMF(k = k)\n        fixed = Fixed()\n        load = Torque()\n        load_step = Blocks.Step(height = tau_L_step, start_time = 3)\n        inertia = Inertia(J = J)\n        friction = Damper(d = f)\n        speed_sensor = SpeedSensor()\n    end\n    @equations begin\n        connect(fixed.flange, emf.support, friction.flange_b)\n        connect(emf.flange, friction.flange_a, inertia.flange_a)\n        connect(inertia.flange_b, load.flange)\n        connect(inertia.flange_b, speed_sensor.flange)\n        connect(load_step.output, load.tau)\n        connect(ref.output, feedback.input1)\n        connect(speed_sensor.w, :y, feedback.input2)\n        connect(feedback.output, pi_controller.err_input)\n        connect(pi_controller.ctr_output, :u, source.V)\n        connect(source.p, R1.p)\n        connect(R1.n, L1.p)\n        connect(L1.n, emf.p)\n        connect(emf.n, source.n, ground.g)\n    end\nend\n\n@named model = DCMotor()\nnothing # hide","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"Now the model can be simulated. Typical rotational mechanical systems are described via DAE (differential algebraic equations), however in this case, ModelingToolkit can simplify the model enough so that it can be represented as a system of ODEs (ordinary differential equations).","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"sys = structural_simplify(model)\nprob = ODEProblem(sys, [sys.L1.i => 0.0], (0, 6.0))\nsol = solve(prob)\n\np1 = plot(sol.t, sol[sys.inertia.w], ylabel = \"Angular Vel. in rad/s\",\n    label = \"Measurement\", title = \"DC Motor with Speed Controller\")\nplot!(sol.t, sol[sys.ref.output.u], label = \"Reference\")\np2 = plot(sol.t, sol[sys.load.tau.u], ylabel = \"Disturbance in Nm\", label = \"\")\nplot(p1, p2, layout = (2, 1))","category":"page"},{"location":"tutorials/dc_motor_pi/#Closed-loop-analysis","page":"DC Motor with Speed Controller","title":"Closed-loop analysis","text":"","category":"section"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"When implementing and tuning a control system in simulation, it is a good practice to analyze the closed-loop properties and verify robustness of the closed-loop with respect to, e.g., modeling errors. To facilitate this, we added two analysis points to the set of connections above, more specifically, we added the analysis points named :y and :u to the connections (for more details on analysis points, see Linear Analysis)","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"connect(sys.speed_sensor.w, :y, sys.feedback.input2)\nconnect(sys.pi_controller.ctr_output, :u, sys.source.V)","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"one at the plant output (:y) and one at the plant input (:u). We may use these analysis points to calculate, e.g., sensitivity functions, illustrated below. Here, we calculate the sensitivity function S(s) and the complimentary sensitivity function T(s) = I - S(s), defined as","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"beginaligned\nS(s) = dfrac1I + P(s)C(s) \nT(s) = dfracP(s)C(s)I + P(s)C(s)\nendaligned","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"using ControlSystemsBase\nmatrices_S, simplified_sys = Blocks.get_sensitivity(\n    model, :y, op = Dict(unknowns(sys) .=> 0.0))\nSo = ss(matrices_S...) |> minreal # The output-sensitivity function as a StateSpace system\nmatrices_T, simplified_sys = Blocks.get_comp_sensitivity(\n    model, :y, op = Dict(sys.inertia.phi => 0.0, sys.inertia.w => 0.0))\nTo = ss(matrices_T...)# The output complementary sensitivity function as a StateSpace system\nbodeplot([So, To], label = [\"S\" \"T\"], plot_title = \"Sensitivity functions\",\n    plotphase = false)","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"Similarly, we may compute the loop-transfer function and plot its Nyquist curve","category":"page"},{"location":"tutorials/dc_motor_pi/","page":"DC Motor with Speed Controller","title":"DC Motor with Speed Controller","text":"matrices_L, simplified_sys = Blocks.get_looptransfer(\n    model, :y, op = Dict(unknowns(sys) .=> 0.0))\nL = -ss(matrices_L...) # The loop-transfer function as a StateSpace system. The negative sign is to negate the built-in negative feedback\nMs, ωMs = hinfnorm(So) # Compute the peak of the sensitivity function to draw a circle in the Nyquist plot\nnyquistplot(L, label = \"\\$L(s)\\$\", ylims = (-2.5, 0.5), xlims = (-1.2, 0.1),\n    Ms_circles = Ms)","category":"page"},{"location":"API/electrical/#ModelingToolkitStandardLibrary:-Electrical-Components","page":"Electrical Components","title":"ModelingToolkitStandardLibrary: Electrical Components","text":"","category":"section"},{"location":"API/electrical/","page":"Electrical Components","title":"Electrical Components","text":"CurrentModule = ModelingToolkitStandardLibrary.Electrical","category":"page"},{"location":"API/electrical/","page":"Electrical Components","title":"Electrical Components","text":"Pages = [\"electrical.md\"]","category":"page"},{"location":"API/electrical/#Index","page":"Electrical Components","title":"Index","text":"","category":"section"},{"location":"API/electrical/","page":"Electrical Components","title":"Electrical Components","text":"Pages = [\"electrical.md\"]","category":"page"},{"location":"API/electrical/#Electrical-Utilities","page":"Electrical Components","title":"Electrical Utilities","text":"","category":"section"},{"location":"API/electrical/","page":"Electrical Components","title":"Electrical Components","text":"Pin\nOnePort\nDigitalPin","category":"page"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.Pin","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.Pin","text":"Pin(; name)\n\nA pin in an analog circuit.\n\nStates:\n\nv(t): [V] The voltage at this pin\ni(t): [A] The current passing through this pin\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.OnePort","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.OnePort","text":"OnePort(; name, v = 0.0, i = 0.0)\n\nComponent with two electrical pins p and n and current i flows from p to n.\n\nStates:\n\nv(t): [V] The voltage across component p.v - n.v\ni(t): [A] The current passing through positive pin\n\nConnectors:\n\np Positive pin\nn Negative pin\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.DigitalPin","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.DigitalPin","text":"DigitalPin(; name)\n\nA pin in a digital circuit.\n\nStates:\n\nv(t): [V] The voltage at this pin\ni(t): [A] The current passing through this pin\nval(t): The binary value of the pin at this point. A voltage from 0V to 0.8V is a binary value of 0.\n\nA voltage in the range 2.0V to 5.0V is 1. Any other value is X.\n\n\n\n\n\n","category":"function"},{"location":"API/electrical/#Analog-Components","page":"Electrical Components","title":"Analog Components","text":"","category":"section"},{"location":"API/electrical/","page":"Electrical Components","title":"Electrical Components","text":"Ground\nResistor\nConductor\nCapacitor\nInductor\nIdealOpAmp\nDiode\nHeatingDiode","category":"page"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.Ground","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.Ground","text":"Ground(; name)\n\nGround node with the potential of zero and connector g. Every circuit must have one ground node.\n\nConnectors:\n\ng\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.Resistor","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.Resistor","text":"Resistor(; name, R)\n\nCreates an ideal Resistor following Ohm's Law.\n\nStates:\n\nSee OnePort\n\nConnectors:\n\np Positive pin\nn Negative pin\n\nParameters:\n\nR: [Ohm] Resistance\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.Conductor","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.Conductor","text":"Conductor(; name, G)\n\nCreates an ideal conductor.\n\nStates:\n\nSee OnePort\n\nConnectors:\n\np Positive pin\nn Negative pin\n\nParameters:\n\nG: [S] Conductance\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.Capacitor","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.Capacitor","text":"Capacitor(; name, C, v)\n\nCreates an ideal capacitor. Initial voltage of capacitor can be set with v ([V])\n\nStates:\n\nSee OnePort\n\nConnectors:\n\np Positive pin\nn Negative pin\n\nParameters:\n\nC: [F] Capacitance\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.Inductor","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.Inductor","text":"Inductor(; name, L, i)\n\nCreates an ideal Inductor. Initial current through inductor can be set with i ([A]).\n\nStates:\n\nSee OnePort\n\nConnectors:\n\np Positive pin\nn Negative pin\n\nParameters:\n\nL: [H] Inductance\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.IdealOpAmp","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.IdealOpAmp","text":"IdealOpAmp(; name)\n\nIdeal operational amplifier (norator-nullator pair). The ideal OpAmp is a two-port. The left port is fixed to v1 = 0 and i1 = 0 (nullator). At the right port both any voltage v2 and any current i2 are possible (norator).\n\nStates:\n\nSee TwoPort\n\nConnectors:\n\np1 Positive pin (left port)\np2 Positive pin (right port)\nn1 Negative pin (left port)\nn2 Negative pin (right port)\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.Diode","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.Diode","text":"    Diode(; name, Is = 1e-6, n = 1, T = 300.15)\n\nIdeal diode based on the Shockley diode equation.\n\nStates\n\n- See [OnePort](@ref)\n\nConnectors\n\n- `p` Positive pin\n- `n` Negative pin\n\nParameters\n\n- `Is`: [`A`] Saturation current\n- `n`: Ideality factor\n- `T`: [K] Ambient temperature\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.HeatingDiode","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.HeatingDiode","text":"HeatingDiode(; name, Is = 1e-6, n = 1)\n\nTemperature dependent diode based on the Shockley diode equation.\n\nStates\n\n- See [OnePort](@ref)\n\nConnectors\n\n- `p` Positive pin\n- `n` Negative pin\n- `port` [HeatPort](@ref) Heat port to model the temperature dependency\n\nParameters:\n\n- `Is`: [`A`] Saturation current\n- `n`: Ideality factor\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#Analog-Sensors","page":"Electrical Components","title":"Analog Sensors","text":"","category":"section"},{"location":"API/electrical/","page":"Electrical Components","title":"Electrical Components","text":"CurrentSensor\nPotentialSensor\nVoltageSensor\nPowerSensor\nMultiSensor","category":"page"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.CurrentSensor","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.CurrentSensor","text":"CurrentSensor(; name)\n\nCreates a circuit component that measures the current flowing through it. Analogous to an ideal ammeter.\n\nStates:\n\ni(t): [A] Current through the sensor\n\nConnectors:\n\np Positive pin\nn Negative pin\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.PotentialSensor","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.PotentialSensor","text":"PotentialSensor(; name)\n\nCreates a circuit component which measures the potential at a pin.\n\nStates:\n\nphi(t): [V] The measured potential at this point\n\nConnectors:\n\np Pin at which potential is to be measured\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.VoltageSensor","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.VoltageSensor","text":"VoltageSensor(; name)\n\nCreates a circuit component that measures the voltage across it. Analogous to an ideal voltmeter.\n\nStates:\n\nv(t): [V] The voltage difference from positive to negative pin p.v - n.v\n\nConnectors:\n\np Positive pin\nn Negative pin\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.PowerSensor","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.PowerSensor","text":"PowerSensor(; name)\n\nCombines a VoltageSensor and a CurrentSensor to measure the power being consumed by a circuit.\n\nStates:\n\npower(t): [W] The power being consumed, given by the product of voltage and current\nSee VoltageSensor\nSee CurrentSensor\n\nConnectors:\n\npc Corresponds to the p pin of the CurrentSensor\nnc Corresponds to the n pin of the CurrentSensor\npv Corresponds to the p pin of the VoltageSensor\nnv Corresponds to the n pin of the VoltageSensor\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.MultiSensor","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.MultiSensor","text":"MultiSensor(; name)\n\nCombines a VoltageSensor and a CurrentSensor.\n\nStates:\n\nv(t): [V] The voltage across the VoltageSensor. Defaults to 1.0.\ni(t): [A] The current across the CurrentSensor. Defaults to 1.0.\n\nConnectors:\n\npc Corresponds to the p pin of the CurrentSensor\nnc Corresponds to the n pin of the CurrentSensor\npv Corresponds to the p pin of the VoltageSensor\nnv Corresponds to the n pin of the VoltageSensor\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#Analog-Sources","page":"Electrical Components","title":"Analog Sources","text":"","category":"section"},{"location":"API/electrical/","page":"Electrical Components","title":"Electrical Components","text":"Voltage\nCurrent","category":"page"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.Voltage","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.Voltage","text":"Voltage(; name)\n\nActs as an ideal voltage source with no internal resistance.\n\nStates:\n\nSee OnePort\n\nConnectors:\n\np Positive pin\nn Negative pin\nV RealInput Input for the voltage control signal, i.e. V ~ p.v - n.v\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#ModelingToolkitStandardLibrary.Electrical.Current","page":"Electrical Components","title":"ModelingToolkitStandardLibrary.Electrical.Current","text":"Current(; name)\n\nActs as an ideal current source with no internal resistance.\n\nStates:\n\nSee OnePort\n\nConnectors:\n\np Positive pin\nn Negative pin\nI RealInput Input for the current control signal, i.e. `I ~ p.i\n\n\n\n\n\n","category":"constant"},{"location":"API/electrical/#Digital-Gates","page":"Electrical Components","title":"Digital Gates","text":"","category":"section"},{"location":"API/electrical/","page":"Electrical Components","title":"Electrical Components","text":"Not\nAnd\nNand\nOr\nNor\nXor\nXnor","category":"page"},{"location":"API/electrical/#Digital-Components","page":"Electrical Components","title":"Digital Components","text":"","category":"section"},{"location":"API/electrical/","page":"Electrical Components","title":"Electrical Components","text":"HalfAdder\nFullAdder\nMUX\nDEMUX\nEncoder\nDecoder","category":"page"},{"location":"API/electrical/#Digital-Sources","page":"Electrical Components","title":"Digital Sources","text":"","category":"section"},{"location":"API/electrical/","page":"Electrical Components","title":"Electrical Components","text":"PulseDiff\nSet\nReset\nPulse","category":"page"},{"location":"connectors/connections/#Introduction","page":"Theory","title":"Introduction","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"In Physical Network Acausal modeling, each physical domain must define a connector to combine model components.  Each physical domain connector defines a minimum of 2 variables, one which is called a Through variable, and one which is called an Across variable.  Both Modelica and SimScape define these variables in the same way:","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Modelica Connectors\nSimScape Connectors","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"However, the standard libraries differ on the selection of the Across variable for the Mechanical Translation and Rotation libraries, Modelica choosing position and angle and SimScape choosing velocity and angular velocity, respectively for Translation and Rotation.  Modelica describes their decision here.  In summary, they would like to provide less integration in the model to avoid lossy numerical behavior, but this decision assumes the lowest order derivative is needed by the model.  Numerically it is possible to define the connector either way, but there are some consequences of this decision, and therefore we will study them in detail here as they relate to ModelingToolkit.","category":"page"},{"location":"connectors/connections/#Through-and-Across-Variable-Theory","page":"Theory","title":"Through and Across Variable Theory","text":"","category":"section"},{"location":"connectors/connections/#General","page":"Theory","title":"General","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"The idea behind the selection of the through variable is that it should be a time derivative of some conserved quantity. The conserved quantity should be expressed by the across variable.  In general terms, the physical system is given by","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Energy Dissipation & Flow:","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"beginaligned\n    partial colorblueacross  partial t cdot c_1 = colorgreenthrough  \n    colorgreenthrough cdot c_2 = colorblueacross\nendaligned","category":"page"},{"location":"connectors/connections/#Electrical","page":"Theory","title":"Electrical","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"For the Electrical domain, the across variable is voltage and the through variable current.  Therefore","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Energy Dissipation:","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"partial colorbluevoltage  partial t cdot capacitance = colorgreencurrent","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Flow:","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"colorgreencurrent cdot resistance = colorbluevoltage","category":"page"},{"location":"connectors/connections/#Translational","page":"Theory","title":"Translational","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"For the translation domain, choosing velocity for the across variable and force for the through gives","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Energy Dissipation:","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"partial colorbluevelocity  partial t cdot mass = colorgreenforce","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Flow:","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"colorgreenforce cdot (1damping) = colorbluevelocity","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"The diagram here shows the similarity of problems in different physical domains.","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"(Image: Through and Across Variables)","category":"page"},{"location":"connectors/connections/#Translational-Connector-using-*Position*-Across-Variable","page":"Theory","title":"Translational Connector using Position Across Variable","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Now, if we choose position for the across variable, a similar relationship can be established, but the pattern must be broken.","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Energy Dissipation:","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"partial^2 colorblueposition  partial t^2 cdot mass = colorgreenforce","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Flow:","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"colorgreenforce cdot (1damping) = partial colorblueposition  partial t","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"As can be seen, we must now establish a higher order derivative to define the Energy Dissipation and Flow equations, requiring an extra equation, as will be shown in the example below.","category":"page"},{"location":"connectors/connections/#Examples","page":"Theory","title":"Examples","text":"","category":"section"},{"location":"connectors/connections/#Electrical-Domain","page":"Theory","title":"Electrical Domain","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"We can generate the above relationship with ModelingToolkit and the ModelingToolkitStandardLibrary using 3 blocks:","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Capacitor: for energy storage with initial voltage = 1V\nResistor: for energy flow\nGround: for energy sink","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"As can be seen, this will give a 1 equation model matching our energy dissipation relationship","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"using ModelingToolkitStandardLibrary.Electrical, ModelingToolkit, DifferentialEquations\nusing ModelingToolkit: t_nounits as t\nusing Plots\n\nsystems = @named begin\n    resistor = Resistor(R = 1)\n    capacitor = Capacitor(C = 1)\n    ground = Ground()\nend\n\neqs = [connect(capacitor.p, resistor.p)\n       connect(resistor.n, ground.g, capacitor.n)]\n\n@named model = ODESystem(eqs, t; systems)\n\nsys = structural_simplify(model)\n\nprintln.(equations(sys))\nnothing # hide","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"The solution shows what we would expect, a non-linear dissipation of voltage and related decrease in current flow…","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"prob = ODEProblem(sys, [1.0], (0, 10.0), [])\nsol = solve(prob)\n\np1 = plot(sol, idxs = [capacitor.v])\np2 = plot(sol, idxs = [resistor.i])\nplot(p1, p2)","category":"page"},{"location":"connectors/connections/#Mechanical-Translational-Domain","page":"Theory","title":"Mechanical Translational Domain","text":"","category":"section"},{"location":"connectors/connections/#Across-Variable-velocity","page":"Theory","title":"Across Variable = velocity","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Now using the Translational library based on velocity, we can see the same relationship with a system reduced to a single equation, using the components:","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Body (i.e. moving mass): for kinetic energy storage with an initial velocity = 1m/s\nDamper: for energy flow\nFixed: for energy sink","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"using ModelingToolkitStandardLibrary\nconst TV = ModelingToolkitStandardLibrary.Mechanical.Translational\n\nsystems = @named begin\n    damping = TV.Damper(d = 1)\n    body = TV.Mass(m = 1)\n    ground = TV.Fixed()\nend\n\neqs = [connect(damping.flange_a, body.flange)\n       connect(ground.flange, damping.flange_b)]\n\n@named model = ODESystem(eqs, t; systems)\n\nsys = structural_simplify(model)\n\nprintln.(full_equations(sys))\nnothing # hide","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"As expected, we have a similar solution…","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"prob = ODEProblem(\n    sys, [], (0, 10.0), []; initialization_eqs = [sys.body.s ~ 0, sys.body.v ~ 1])\nsol_v = solve(prob)\n\np1 = plot(sol_v, idxs = [body.v])\np2 = plot(sol_v, idxs = [damping.f])\nplot(p1, p2)","category":"page"},{"location":"connectors/connections/#Across-Variable-position","page":"Theory","title":"Across Variable = position","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Now, let's consider the position-based approach.  We can build the same model with the same components.  As can be seen, we now end of up with 2 equations, because we need to relate the lower derivative (position) to force (with acceleration).","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"const TP = ModelingToolkitStandardLibrary.Mechanical.TranslationalPosition\n\nsystems = @named begin\n    damping = TP.Damper(d = 1, va = 1, vb = 0.0)\n    body = TP.Mass(m = 1, v = 1)\n    ground = TP.Fixed(s_0 = 0)\nend\n\neqs = [connect(damping.flange_a, body.flange)\n       connect(ground.flange, damping.flange_b)]\n\n@named model = ODESystem(eqs, t; systems)\n\nsys = structural_simplify(model)\n\nprintln.(full_equations(sys))\nnothing # hide","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"As can be seen, we get exactly the same result.  The only difference here is that we are solving an extra equation, which allows us to plot the body position as well.","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"prob = ODEProblem(sys, [], (0, 10.0), [])\nsol_p = solve(prob)\n\np1 = plot(sol_p, idxs = [body.v])\np2 = plot(sol_p, idxs = [damping.f])\np3 = plot(sol_p, idxs = [body.s])\n\nplot(p1, p2, p3)","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"The question then arises, can the position be plotted when using the Mechanical Translational Domain based on the Velocity Across variable?  Yes, we can!  There are 2 solutions:","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"the Mass component will add the position variable when the s parameter is used to set an initial position. Otherwise, the component does not track the position.","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"@named body = TV.Mass(m = 1, v = 1, s = 0)","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"implement a PositionSensor TODO: Implement Translation Sensors","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Either option will produce the same result regardless of which across variable is used.  If the same result is given, why are both options included in the Standard Library, what are the differences?  These differences will be discussed next so that an informed decision can be made about which domain is best for your model.","category":"page"},{"location":"connectors/connections/#Mechanical/Translational-Library-Differences-(Velocity-vs.-Position-Connectors)","page":"Theory","title":"Mechanical/Translational Library Differences (Velocity vs. Position Connectors)","text":"","category":"section"},{"location":"connectors/connections/#Initialization","page":"Theory","title":"Initialization","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"The main difference between ModelingToolkitStandardLibrary.Mechanical.Translational and ModelingToolkitStandardLibrary.Mechanical.TranslationalPosition is how they are initialized.  In the ModelingToolkitStandardLibrary initialization, parameters are defined at the component level, so we simply need to be careful to set the correct initial conditions for the domain that it used.  Let's use the following example problem to explain the differences.","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"(Image: Example Mechanical Model)","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"In this problem, we have a mass, spring, and damper which are connected to a fixed point.  Let's see how each component is defined.","category":"page"},{"location":"connectors/connections/#Damper","page":"Theory","title":"Damper","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"The damper will connect the flange/flange 1 (flange_a) to the mass, and flange/flange 2 (flange_b) to the fixed point.  For both position- and velocity-based domains, we set the damping constant d=1 and va=1 and leave the default for v_b_0 at 0.  For the position domain, we also need to set the initial positions for flange_a and flange_b.","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"@named dv = TV.Damper(d = 1)\n@named dp = TP.Damper(d = 1, va = 1, vb = 0.0, flange_a__s = 3, flange_b__s = 1)\nnothing # hide","category":"page"},{"location":"connectors/connections/#Spring","page":"Theory","title":"Spring","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"The spring will connect the flange/flange 1 (flange_a) to the mass, and flange/flange 2 (flange_b) to the fixed point.  For both position- and velocity-based domains, we set the spring constant k=1.  The velocity domain then requires the initial velocity va and initial spring stretch delta_s.  The position domain instead needs the initial positions for flange_a and flange_b and the natural spring length l.","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"@named sv = TV.Spring(k = 1)\n@named sp = TP.Spring(k = 1, flange_a__s = 3, flange_b__s = 1, l = 1)\nnothing # hide","category":"page"},{"location":"connectors/connections/#Mass","page":"Theory","title":"Mass","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"For both position- and velocity-based domains, we set the mass m=1 and initial velocity v=1. Like the damper, the position domain requires the position initial conditions set as well.","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"@named bv = TV.Mass(m = 1)\n@named bp = TP.Mass(m = 1, v = 1, s = 3)\nnothing # hide","category":"page"},{"location":"connectors/connections/#Fixed","page":"Theory","title":"Fixed","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Here the velocity domain requires no initial condition, but for our model to work as defined we must set the position domain component to the correct initial position.","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"@named gv = TV.Fixed()\n@named gp = TP.Fixed(s_0 = 1)\nnothing # hide","category":"page"},{"location":"connectors/connections/#Comparison","page":"Theory","title":"Comparison","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"As can be seen, the position-based domain requires more initial condition information to be properly defined, since the absolute position information is required. Therefore, based on the model being described, it may be more natural to choose one domain over the other.","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Let's define a quick function to simplify and solve the 2 different systems. Note, we will solve with a fixed time step and a set tolerance to compare the numerical differences.","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"function simplify_and_solve(damping, spring, body, ground; initialization_eqs = Equation[])\n    eqs = [connect(spring.flange_a, body.flange, damping.flange_a)\n           connect(spring.flange_b, damping.flange_b, ground.flange)]\n\n    @named model = ODESystem(eqs, t; systems = [ground, body, spring, damping])\n\n    sys = structural_simplify(model)\n\n    println.(full_equations(sys))\n\n    prob = ODEProblem(sys, [], (0, 10.0), []; initialization_eqs)\n    sol = solve(prob; abstol = 1e-9, reltol = 1e-9)\n\n    return sol\nend\nnothing # hide","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Now let's solve the velocity domain model","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"initialization_eqs = [bv.s ~ 3\n                      bv.v ~ 1\n                      sv.delta_s ~ 1]\nsolv = simplify_and_solve(dv, sv, bv, gv; initialization_eqs);\nnothing # hide","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"And the position domain model","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"solp = simplify_and_solve(dp, sp, bp, gp);\nnothing # hide","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Now we can plot the comparison of the 2 models and see they give the same result.","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"plot(ylabel = \"mass velocity [m/s]\")\nplot!(solv, idxs = [bv.v])\nplot!(solp, idxs = [bp.v])","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"But, what if we wanted to plot the mass position?  This is easy for the position-based domain, we have the state bp₊s(t), but for the velocity-based domain we have sv₊delta_s(t) which is the spring stretch.  To get the absolute position, we add the spring natural length (1m) and the fixed position (1m).  As can be seen, we then get the same result.","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"plot(ylabel = \"mass position [m]\")\nplot!(solv, idxs = [sv.delta_s + 1 + 1])\nplot!(solp, idxs = [bp.s])","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"So in conclusion, the position based domain gives easier access to absolute position information, but requires more initial condition information.","category":"page"},{"location":"connectors/connections/#Accuracy","page":"Theory","title":"Accuracy","text":"","category":"section"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"One may then ask, what the trade-off in terms of numerical accuracy is. When we look at the simplified equations, we can see that actually both systems solve the same equations.  The differential equations of the velocity domain are","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"beginaligned\nm cdot dotv +  d cdot v + k cdot Delta s = 0  \ndotDelta s = v\nendaligned","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"And for the position domain are","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"beginaligned\nm cdot dotv +  d cdot v + k cdot (s - s_b_0 - l) = 0   \ndots = v\nendaligned","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"By definition, the spring stretch is","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Delta s = s - s_b_0 - l","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"Which means both systems are actually solving the same exact system.  We can plot the numerical difference between the 2 systems and see the result is negligible (much less than the tolerance of 1e-9).","category":"page"},{"location":"connectors/connections/","page":"Theory","title":"Theory","text":"plot(title = \"numerical difference: vel. vs. pos. domain\", xlabel = \"time [s]\",\n    ylabel = \"solv[bv.v] .- solp[bp.v]\")\ntime = 0:0.1:10\nplot!(time, (solv(time)[bv.v] .- solp(time)[bp.v]), label = \"\")","category":"page"},{"location":"tutorials/custom_component/#Custom-Component","page":"Custom Components","title":"Custom Component","text":"","category":"section"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"In this tutorial, the creation of a custom component is demonstrated via the Chua's circuit. The circuit is a simple circuit that shows chaotic behavior. Except for a non-linear resistor, every other component already is part of ModelingToolkitStandardLibrary.Electrical.","category":"page"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"First, we need to make some imports.","category":"page"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t\nusing ModelingToolkitStandardLibrary.Electrical\nusing OrdinaryDiffEq\nusing Plots","category":"page"},{"location":"tutorials/custom_component/#Custom-Component-2","page":"Custom Components","title":"Custom Component","text":"","category":"section"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"Now the custom component can be defined. The Modelica implementation of the NonlinearResistor looks as follows:","category":"page"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"model NonlinearResistor \"Chua's resistor\"\n  extends Interfaces.OnePort;\n\n  parameter SI.Conductance Ga \"conductance in inner voltage range\";\n  parameter SI.Conductance Gb \"conductance in outer voltage range\";\n  parameter SI.Voltage Ve \"inner voltage range limit\";\nequation\n  i = if (v < -Ve) then Gb*(v + Ve) - Ga*Ve else if (v > Ve) then Gb*(v - Ve) + Ga*Ve else Ga*v;\nend NonlinearResistor;","category":"page"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"this can almost be directly translated to the syntax of ModelingToolkit.","category":"page"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"@mtkmodel NonlinearResistor begin\n    @extend OnePort()\n    @parameters begin\n        Ga\n        Gb\n        Ve\n    end\n    @equations begin\n        i ~ ifelse(v < -Ve,\n            Gb * (v + Ve) - Ga * Ve,\n            ifelse(v > Ve,\n                Gb * (v - Ve) + Ga * Ve,\n                Ga * v))\n    end\nend\nnothing # hide","category":"page"},{"location":"tutorials/custom_component/#Explanation","page":"Custom Components","title":"Explanation","text":"","category":"section"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"Since the non-linear resistor is essentially a standard electrical component with two ports, we can extend from the OnePort component of the library.","category":"page"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"@extend OnePort()","category":"page"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"This extends OnePort and unpacks v and i variables.","category":"page"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"It might be a good idea to create parameters for the constants of the NonlinearResistor.","category":"page"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"@parameters begin\n    Ga\n    Gb\n    Ve\nend","category":"page"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"This creates symbolic parameters with the name Ga, Gb and Ve whose default values are set from the function's arguments Ga, Gb and Ve, respectively. This allows the user to remake the problem easily with different parameters or allow for auto-tuning or parameter optimization without having to do all the costly steps that may be involved with building and simplifying a model. The non-linear (in this case piece-wise constant) equation for the current can be implemented using ifelse.","category":"page"},{"location":"tutorials/custom_component/#Building-the-Model","page":"Custom Components","title":"Building the Model","text":"","category":"section"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"The final model can now be created with the components from the library and the new custom component.","category":"page"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"@mtkmodel ChaoticAttractor begin\n    @components begin\n        inductor = Inductor(L = 18, i = 0)\n        resistor = Resistor(R = 12.5e-3)\n        conductor = Conductor(G = 0.565)\n        capacitor1 = Capacitor(C = 10, v = 4)\n        capacitor2 = Capacitor(C = 100, v = 0)\n        non_linear_resistor = NonlinearResistor(\n            Ga = -0.757576,\n            Gb = -0.409091,\n            Ve = 1\n        )\n        ground = Ground()\n    end\n    @equations begin\n        connect(inductor.p, conductor.p)\n        connect(conductor.n, non_linear_resistor.p)\n        connect(capacitor1.p, conductor.n)\n        connect(inductor.n, resistor.p)\n        connect(conductor.p, capacitor2.p)\n        connect(capacitor1.n, capacitor2.n, non_linear_resistor.n, resistor.n, ground.g)\n    end\nend\nnothing # hide","category":"page"},{"location":"tutorials/custom_component/#Simulating-the-Model","page":"Custom Components","title":"Simulating the Model","text":"","category":"section"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"@mtkbuild builds a structurally simplified ChaoticAttractor model. Since the initial voltage of the capacitors was already specified via v and the initial current of inductor via i, no initial condition is given and an empty pair is supplied.","category":"page"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"@mtkbuild sys = ChaoticAttractor()\nprob = ODEProblem(sys, Pair[], (0, 5e4))\nsol = solve(prob; saveat = 1.0)\n\nplot(sol[sys.capacitor1.v], sol[sys.capacitor2.v], title = \"Chaotic Attractor\", label = \"\",\n    ylabel = \"C1 Voltage in V\", xlabel = \"C2 Voltage in V\")","category":"page"},{"location":"tutorials/custom_component/","page":"Custom Components","title":"Custom Components","text":"plot(sol; idxs = [sys.capacitor1.v, sys.capacitor2.v, sys.inductor.i],\n    labels = [\"C1 Voltage in V\" \"C2 Voltage in V\" \"Inductor Current in A\"])","category":"page"},{"location":"tutorials/rc_circuit/#RC-Circuit-Model","page":"RC Circuit","title":"RC Circuit Model","text":"","category":"section"},{"location":"tutorials/rc_circuit/","page":"RC Circuit","title":"RC Circuit","text":"This tutorial is a simplified version of the RC circuit tutorial in the ModelingToolkit.jl documentation. In that tutorial, the full RC circuit is built from scratch. Here, we will use the components of the Electrical model in the ModelingToolkit Standard Library to simply connect pre-made components and simulate the model.","category":"page"},{"location":"tutorials/rc_circuit/","page":"RC Circuit","title":"RC Circuit","text":"using ModelingToolkit, OrdinaryDiffEq, Plots\nusing ModelingToolkitStandardLibrary.Electrical\nusing ModelingToolkitStandardLibrary.Blocks: Constant\nusing ModelingToolkit: t_nounits as t\n\n@mtkmodel RC begin\n    @parameters begin\n        R = 1.0\n        C = 1.0\n        V = 1.0\n    end\n    @components begin\n        resistor = Resistor(R = R)\n        capacitor = Capacitor(C = C, v = 0.0)\n        source = Voltage()\n        constant = Constant(k = V)\n        ground = Ground()\n    end\n    @equations begin\n        connect(constant.output, source.V)\n        connect(source.p, resistor.p)\n        connect(resistor.n, capacitor.p)\n        connect(capacitor.n, source.n, ground.g)\n    end\nend\n\n@mtkbuild sys = RC()\nprob = ODEProblem(sys, Pair[], (0, 10.0))\nsol = solve(prob)\n\nplot(sol, idxs = [sys.capacitor.v, sys.resistor.i],\n    title = \"RC Circuit Demonstration\",\n    labels = [\"Capacitor Voltage\" \"Resistor Current\"])","category":"page"},{"location":"API/mechanical/#ModelingToolkit-Standard-Library:-Mechanical-Components","page":"Mechanical Components","title":"ModelingToolkit Standard Library: Mechanical Components","text":"","category":"section"},{"location":"API/mechanical/","page":"Mechanical Components","title":"Mechanical Components","text":"Pages = [\"mechanical.md\"]\nDepth = 3","category":"page"},{"location":"API/mechanical/#Index","page":"Mechanical Components","title":"Index","text":"","category":"section"},{"location":"API/mechanical/","page":"Mechanical Components","title":"Mechanical Components","text":"Pages = [\"mechanical.md\"]","category":"page"},{"location":"API/mechanical/#Rotational-Components","page":"Mechanical Components","title":"Rotational Components","text":"","category":"section"},{"location":"API/mechanical/","page":"Mechanical Components","title":"Mechanical Components","text":"CurrentModule = ModelingToolkitStandardLibrary.Mechanical.Rotational","category":"page"},{"location":"API/mechanical/#Rotational-Utils","page":"Mechanical Components","title":"Rotational Utils","text":"","category":"section"},{"location":"API/mechanical/","page":"Mechanical Components","title":"Mechanical Components","text":"Flange\nSupport\nPartialCompliantWithRelativeStates\nPartialElementaryOneFlangeAndSupport2\nPartialElementaryTwoFlangesAndSupport2\nPartialCompliant","category":"page"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.Flange","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.Flange","text":"Support(;name)\n\n1-dim. rotational flange of a shaft.\n\nStates:\n\nphi(t): [rad] Absolute rotation angle of flange\ntau(t): [N.m] Cut torque in the flange\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.Support","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.Support","text":"Support(;name)\n\nSupport/housing of a 1-dim. rotational shaft\n\nStates:\n\nphi(t): [rad] Absolute rotation angle of the support/housing\ntau(t): [N.m] Cut torque in the support/housing\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.PartialCompliantWithRelativeStates","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.PartialCompliantWithRelativeStates","text":"PartialCompliantWithRelativeStates(; name, phi_rel = 0.0, tau = 0.0)\n\nPartial model for the compliant connection of two rotational 1-dim. shaft flanges where the relative angle and speed are used as preferred states\n\nStates:\n\nphi_rel(t): [rad] Relative rotation angle (= flangeb.phi - flangea.phi). It accepts an initial value, which defaults to 0.0.\nw_rel(t): [rad/s] Relative angular velocity (= D(phi_rel)). It accepts an initial value, which defaults to 0.0.\na_rel(t): [rad/s²] Relative angular acceleration (= D(w_rel)). It accepts an initial value, which defaults to 0.0.\ntau(t): [N.m] Torque between flanges (= flange_b.tau). It accepts an initial value, which defaults to 0.0.\n\nConnectors:\n\nflange_a Flange\nflange_b Flange\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.PartialElementaryOneFlangeAndSupport2","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.PartialElementaryOneFlangeAndSupport2","text":"PartialElementaryOneFlangeAndSupport2(; name, use_support = false)\n\nPartial model for a component with one rotational 1-dim. shaft flange and a support used for textual modeling, i.e., for elementary models\n\nStates:\n\nphi_support(t): [rad] Absolute angle of support flange\"\n\nConnectors:\n\nflange Flange\n\nParameters:\n\nuse_support: If support flange enabled, otherwise implicitly grounded\n\n\n\n\n\n","category":"function"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.PartialElementaryTwoFlangesAndSupport2","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.PartialElementaryTwoFlangesAndSupport2","text":"PartialElementaryTwoFlangesAndSupport2(;name, use_support=false)\n\nPartial model for a component with two rotational 1-dim. shaft flanges and a support used for textual modeling, i.e., for elementary models\n\nStates:\n\nphi_support(t): [rad] Absolute angle of support flange\n\nConnectors:\n\nflange_a Flange\nflange_b Flange\nsupport Support  if use_support == true\n\nParameters:\n\nuse_support: If support flange enabled, otherwise implicitly grounded\n\n\n\n\n\n","category":"function"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.PartialCompliant","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.PartialCompliant","text":"PartialCompliant(;  name, phi_rel = 0.0, tau = 0.0)\n\nPartial model for the compliant connection of two rotational 1-dim. shaft flanges.\n\nStates:\n\nphi_rel(t): [rad] Relative rotation angle (flange_b.phi - flange_a.phi). It accepts an initial value, which defaults to 0.0.\ntau(t): [N.m] Torque between flanges (flange_b.tau). It accepts an initial value, which defaults to 0.0.\n\nConnectors:\n\nflange_a Flange\nflange_b Flange\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#Rotational-Core-Components","page":"Mechanical Components","title":"Rotational Core Components","text":"","category":"section"},{"location":"API/mechanical/","page":"Mechanical Components","title":"Mechanical Components","text":"Fixed\nInertia\nSpring\nDamper\nSpringDamper\nIdealGear\nRotationalFriction","category":"page"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.Fixed","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.Fixed","text":"Fixed(;name, phi0 = 0.0)\n\nFlange fixed in housing at a given angle.\n\nConnectors:\n\nflange Flange\n\nParameters:\n\nphi0: [rad] Fixed offset angle of housing\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.Inertia","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.Inertia","text":"Inertia(;name, J, phi = 0.0, w = 0.0, a = 0.0)\n\n1D-rotational component with inertia.\n\nStates:\n\nphi: [rad] Absolute rotation angle of component\nw: [rad/s] Absolute angular velocity of component (= D(phi))\na: [rad/s²] Absolute angular acceleration of component (= D(w))\n\nConnectors:\n\nflange_a Flange Left flange\nflange_b Flange Right flange\n\nParameters:\n\nJ: [kg·m²] Moment of inertia\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.Spring","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.Spring","text":"Spring(; name, c, phi_rel0 = 0.0)\n\nLinear 1D rotational spring\n\nStates:\n\nphi_rel(t): [rad] Relative rotation angle (flange_b.phi - flange_a.phi)\ntau(t): [N.m] Torque between flanges (flange_b.tau)\n\nConnectors:\n\nflange_a Flange\nflange_b Flange\n\nParameters:\n\nc: [N.m/rad] Spring constant\nphi_rel0: [rad] Unstretched spring angle. Defaults to 0.0.\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.Damper","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.Damper","text":"Damper(; name, d)\n\nLinear 1D rotational damper\n\nStates:\n\nphi_rel(t): [rad] Relative rotation angle (= flangeb.phi - flangea.phi)\nw_rel(t): [rad/s] Relative angular velocity (= D(phi_rel))\na_rel(t): [rad/s²] Relative angular acceleration (= D(w_rel))\ntau(t): [N.m] Torque between flanges (= flange_b.tau)\n\nConnectors:\n\nflange_a Flange\nflange_b Flange\n\nParameters:\n\nd: [N.m.s/rad] Damping constant\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.SpringDamper","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.SpringDamper","text":"SpringDamper(; name, d)\n\nLinear 1D rotational spring and damper\n\nStates:\n\nphi_rel(t): [rad] Relative rotation angle (= flangeb.phi - flangea.phi)\nw_rel(t): [rad/s] Relative angular velocity (= D(phi_rel))\na_rel(t): [rad/s²] Relative angular acceleration (= D(w_rel))\ntau(t): [N.m] Torque between flanges (= flange_b.tau)\n\nConnectors:\n\nflange_a Flange\nflange_b Flange\n\nParameters:\n\nd: [N.m.s/rad] Damping constant\nc: [N.m/rad] Spring constant\nphi_rel0: [rad] Unstretched spring angle. Defaults to 0.0\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.IdealGear","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.IdealGear","text":"IdealGear(; name, ratio, use_support = false)\n\nIdeal gear without inertia.\n\nThis element characterizes any type of gear box which is fixed in the ground and which has one driving shaft and one driven shaft.\n\nStates:\n\nphi_a(t): [rad] Relative angle between shaft a and the support\nphi_b(t): [rad] Relative angle between shaft b and the support\n\nConnectors:\n\nflange_a Flange\nflange_b Flange\nsupport Support if use_support == true\n\nParameters:\n\nratio: Transmission ratio (flangea.phi/flangeb.phi)\nuse_support: If support flange enabled, otherwise implicitly grounded. By default it is false\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.RotationalFriction","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.RotationalFriction","text":"RotationalFriction(; name, f, tau_c, w_brk, tau_brk)\n\nModels rotational friction with Stribeck effect, Coulomb friction and viscous friction between the two flanges. The friction torque is a function of the relative angular velocity between flange_a and flange_b.\n\nFriction model: \"Armstrong, B. and C.C. de Wit, Friction Modeling and Compensation, The Control Handbook, CRC Press, 1995.\"\n\nStates:\n\nphi_rel(t): [rad] Relative rotation angle (= flange_b.phi - flange_a.phi)\nw_rel(t): [rad/s] Relative angular velocity (= D(phi_rel))\na_rel(t): [rad/s²] Relative angular acceleration (= D(w_rel))\ntau(t): [N.m] Torque between flanges (= flange_b.tau)\n\nConnectors:\n\nflange_a Flange\nflange_b Flange\n\nParameters:\n\nf: [N⋅m/(rad/s)] Viscous friction coefficient\ntau_c: [N⋅m] Coulomb friction torque\nw_brk: [rad/s] Breakaway friction velocity\ntau_brk: [N⋅m] Breakaway friction torque\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#Rotational-Sources","page":"Mechanical Components","title":"Rotational Sources","text":"","category":"section"},{"location":"API/mechanical/","page":"Mechanical Components","title":"Mechanical Components","text":"Torque\nSpeed\nPosition","category":"page"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.Torque","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.Torque","text":"Torque(; name, use_support = false)\n\nInput signal acting as external torque on a flange\n\nStates:\n\nphi_support(t): [rad] Absolute angle of support flange\n\nConnectors:\n\nflange Flange\ntau RealInput  Accelerating torque acting at flange -flange.tau\n\nParameters:\n\nuse_support\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.Speed","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.Speed","text":"Speed(; name, use_support = false, exact = false, f_crit = 50)\n\nForced movement of a flange according to a reference angular velocity signal\n\nStates:\n\nphi_support(t): [rad] Absolute angle of support flange\"\n\nConnectors:\n\nflange Flange\nw_ref RealInput Reference angular velocity of flange with respect to support as input signal needs to be continuously differential\n\nParameters:\n\nuse_support: If support flange enabled, otherwise implicitly grounded\nexact: true/false exact treatment/filtering the input signal\ntau_filt: [rad/s] if exact=false, Time constant of low-pass filter to filter input signal\n\n\n\n\n\n","category":"function"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.Position","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.Position","text":"Position(; name, exact = false, f_crit = 50, use_support = false)\n\nForced movement of a flange according to a reference angle signal.\n\nThe input signal phi_ref defines the reference angle in [rad]. Flange is forced to move according to this reference motion relative to flange support. According to parameter exact (default = false), this is done in the following way:\n\nexact=true: The reference angle is treated exactly. This is only possible if the input signal is defined by an analytical function that can be differentiated at least twice in order to compute the acceleration.\nexact=false: The reference angle is filtered and the second derivative of the filtered curve is used to compute the reference acceleration of the flange. This second derivative is not computed by numerical differentiation but by an appropriate realization of the filter. For filtering, a second-order Bessel filter is used. The critical frequency (also called cut-off frequency) of the filter is defined via parameter f_crit in [Hz]. This value should be selected in such a way that it is higher than the essential low frequencies in the signal.\n\nConnectors\n\nflange::Flange: Flange to be moved\nphi_ref::RealInput: Reference angle of flange with respect to support\n\nVariables\n\nphi(t): Rotation angle of flange with respect to support\nw(t): If exact=false, Angular velocity of flange with respect to support\na(t): If exact=false, Angular acceleration of flange with respect to support\n\nParameters\n\nexact: (structural) true/false exact treatment/filtering the input signal\nf_crit: [Hz] if exact=false, Critical frequency of filter to filter input signal\n\n\n\n\n\n","category":"function"},{"location":"API/mechanical/#Rotational-Sensors","page":"Mechanical Components","title":"Rotational Sensors","text":"","category":"section"},{"location":"API/mechanical/","page":"Mechanical Components","title":"Mechanical Components","text":"AngleSensor\nSpeedSensor\nTorqueSensor\nRelSpeedSensor","category":"page"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.AngleSensor","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.AngleSensor","text":"AngleSensor(; name)\n\nIdeal sensor to measure the absolute flange angle\n\nConnectors:\n\nflange: Flange Flange of shaft from which sensor information shall be measured\nphi: RealOutput Absolute angle of flange\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.SpeedSensor","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.SpeedSensor","text":"SpeedSensor(; name)\n\nIdeal sensor to measure the absolute flange angular velocity\n\nConnectors:\n\nflange: Flange Flange of shaft from which sensor information shall be measured\nw: RealOutput Absolute angular velocity of flange\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.TorqueSensor","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.TorqueSensor","text":"TorqueSensor(;name)\n\nIdeal sensor to measure the torque between two flanges (= flange_a.tau)\n\nConnectors:\n\nflange_a: Flange Left flange of shaft\nflange_b: Flange Left flange of shaft\ntau: RealOutput Torque in flange flangea and flangeb (tau = flange_a.tau = -flange_b.tau)\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Rotational.RelSpeedSensor","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Rotational.RelSpeedSensor","text":"RelSpeedSensor(; name)\n\nIdeal sensor to measure the relative angular velocity\n\nConnectors:\n\nflange_a: Flange Flange of shaft from which sensor information shall be measured\nflange_b: Flange Flange of shaft from which sensor information shall be measured\nw: RealOutput Absolute angular velocity of flange\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#Translational-Components","page":"Mechanical Components","title":"Translational Components","text":"","category":"section"},{"location":"API/mechanical/","page":"Mechanical Components","title":"Mechanical Components","text":"CurrentModule = ModelingToolkitStandardLibrary.Mechanical.Translational","category":"page"},{"location":"API/mechanical/#Translational-Utils","page":"Mechanical Components","title":"Translational Utils","text":"","category":"section"},{"location":"API/mechanical/","page":"Mechanical Components","title":"Mechanical Components","text":"MechanicalPort","category":"page"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Translational.MechanicalPort","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Translational.MechanicalPort","text":"MechanicalPort(;name)\n\n1-dim. rotational flange of a shaft.\n\nStates:\n\nv: [m/s] velocity of the node\nf: [N] force entering the node\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#Translational-Core-Components","page":"Mechanical Components","title":"Translational Core Components","text":"","category":"section"},{"location":"API/mechanical/","page":"Mechanical Components","title":"Mechanical Components","text":"Mass\nSpring\nDamper\nFixed","category":"page"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Translational.Mass","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Translational.Mass","text":"Mass(; name, m, g = 0)\n\nSliding mass with inertia\n\nParameters:\n\nm: [kg] mass of sliding body\ng = 0: [m/s^2] [m/s²] gravity field acting on the mass, positive value acts in the positive direction\n\nStates:\n\nv: [m/s] absolute linear velocity of sliding mass\ns: [m] absolute position of sliding mass (optional with parameter s)\n\nConnectors:\n\nflange: 1-dim. translational flange\n\n\n\n\n\n","category":"function"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Translational.Spring","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Translational.Spring","text":"Spring(; name, k, delta_s = 0.0,  va=0.0, v_b_0=0.0)\n\nLinear 1D translational spring\n\nParameters:\n\nk: [N/m] Spring constant\ndelta_s: initial spring stretch\nva: [m/s] Initial value of absolute linear velocity at flange_a (default 0 m/s)\nv_b_0: [m/s] Initial value of absolute linear velocity at flange_b (default 0 m/s)\n\nConnectors:\n\nflange_a: 1-dim. translational flange on one side of spring\nflange_b: 1-dim. translational flange on opposite side of spring\n\n\n\n\n\n","category":"function"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Translational.Damper","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Translational.Damper","text":"Damper(; name, d, flange_a.v = 0.0, flange_b.v = 0.0)\n\nLinear 1D translational damper\n\nParameters:\n\nd: [N.s/m] Damping constant\n\nConnectors:\n\nflange_a: 1-dim. translational flange on one side of damper. Initial value of state v is set to 0.0 m/s.\nflange_b: 1-dim. translational flange on opposite side of damper. Initial value of state v is set to 0.0 m/s.\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Translational.Fixed","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Translational.Fixed","text":"Fixed(; name)\n\nFixes a flange position (velocity = 0)\n\nConnectors:\n\nflange: 1-dim. translational flange\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#Translational-Sources","page":"Mechanical Components","title":"Translational Sources","text":"","category":"section"},{"location":"API/mechanical/","page":"Mechanical Components","title":"Mechanical Components","text":"Force\nPosition\nVelocity\nAcceleration","category":"page"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Translational.Force","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Translational.Force","text":"Force(; name)\n\nLinear 1D force input source\n\nConnectors:\n\nflange: 1-dim. translational flange\nf: real input\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Translational.Position","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Translational.Position","text":"Position(solves_force = true; name)\n\nLinear 1D position input source.  Set solves_force=false to force input force to 0 (i.e. only the position is given, the respective force needed is already provided elsewhere in the model).  \n\nConnectors:\n\nflange: 1-dim. translational flange\ns: real input\n\n\n\n\n\n","category":"function"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Translational.Velocity","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Translational.Velocity","text":"Velocity(solves_force = true; name)\n\nLinear 1D position input source.  Set solves_force=false to force input force to 0 (i.e. only the velocity is given, the respective force needed is already provided elsewhere in the model).  \n\nConnectors:\n\nflange: 1-dim. translational flange\nv: real input\n\n\n\n\n\n","category":"function"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Translational.Acceleration","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Translational.Acceleration","text":"Acceleration(solves_force = true; name)\n\nLinear 1D position input source.  Set solves_force=false to force input force to 0 (i.e. only the acceleration is given, the respective force needed is already provided elsewhere in the model).  \n\nConnectors:\n\nflange: 1-dim. translational flange\na: real input\n\n\n\n\n\n","category":"function"},{"location":"API/mechanical/#Translational-Sensors","page":"Mechanical Components","title":"Translational Sensors","text":"","category":"section"},{"location":"API/mechanical/","page":"Mechanical Components","title":"Mechanical Components","text":"ForceSensor\nPositionSensor\nAccelerationSensor","category":"page"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Translational.ForceSensor","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Translational.ForceSensor","text":"ForceSensor(; name)\n\nLinear 1D force sensor, measures the force between two flanges.\n\nConnectors:\n\nflange: 1-dim. translational flange\noutput: real output\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Translational.PositionSensor","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Translational.PositionSensor","text":"PositionSensor(; s = 0, name)\n\nLinear 1D position sensor.\n\nStates:\n\ns: [m] absolute position (with initial value of 0.0)\n\nConnectors:\n\nflange: 1-dim. translational flange\noutput: real output\n\n\n\n\n\n","category":"constant"},{"location":"API/mechanical/#ModelingToolkitStandardLibrary.Mechanical.Translational.AccelerationSensor","page":"Mechanical Components","title":"ModelingToolkitStandardLibrary.Mechanical.Translational.AccelerationSensor","text":"AccelerationSensor(; name)\n\nLinear 1D acceleration sensor.\n\nStates:\n\na: [m/s^2] measured acceleration\n\nConnectors:\n\nflange: 1-dim. translational flange\noutput: real output\n\n\n\n\n\n","category":"constant"},{"location":"API/linear_analysis/#Linear-Analysis","page":"Linear Analysis","title":"Linear Analysis","text":"","category":"section"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"danger: Experimental\nThe interface described here is currently experimental and at any time subject to breaking changes not respecting semantic versioning.","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"Linear analysis refers to the process of linearizing a nonlinear model and analysing the resulting linear dynamical system. To facilitate linear analysis, ModelingToolkitStandardLibrary provides the concept of an AnalysisPoint, which can be inserted in-between two causal blocks (such as those from the Blocks sub module). Once a model containing analysis points is built, several operations are available:","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"get_sensitivity get the sensitivity function (wiki), S(s), as defined in the field of control theory.\nget_comp_sensitivity get the complementary sensitivity function T(s)  S(s)+T(s)=1.\nget_looptransfer get the (open) loop-transfer function where the loop starts and ends in the analysis point. For a typical simple feedback connection with a plant P(s) and a controller C(s), the loop-transfer function at the plant output is P(s)C(s).\nlinearize can be called with two analysis points denoting the input and output of the linearized system.\nopen_loop return a new (nonlinear) system where the loop has been broken in the analysis point, i.e., the connection the analysis point usually implies has been removed.","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"An analysis point can be created explicitly using the constructor AnalysisPoint, or automatically when connecting two causal components using connect:","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"connect(comp1.output, :analysis_point_name, comp2.input)","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"warning: Causality\nAnalysis points are causal, i.e., they imply a directionality for the flow of information. The order of the connections in the connect statement is thus important, i.e., connect(out, :name, in) is different from connect(in, :name, out).","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"The directionality of an analysis point can be thought of as an arrow in a block diagram, where the name of the analysis point applies to the arrow itself.","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"┌─────┐         ┌─────┐\n│     │  name   │     │\n│  out├────────►│in   │\n│     │         │     │\n└─────┘         └─────┘","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"This is signified by the name being the middle argument to connect.","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"Of the above mentioned functions, all except for open_loop return the output of ModelingToolkit.linearize, which is","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"matrices, simplified_sys = linearize(...)\n# matrices = (; A, B, C, D)","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"i.e., matrices is a named tuple containing the matrices of a linear state-space system on the form","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"beginaligned\ndot x = Ax + Bu\ny = Cx + Du\nendaligned","category":"page"},{"location":"API/linear_analysis/#Example","page":"Linear Analysis","title":"Example","text":"","category":"section"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"The following example builds a simple closed-loop system with a plant P and a controller C. Two analysis points are inserted, one before and one after P. We then derive a number of sensitivity functions and show the corresponding code using the package ControlSystemBase.jl","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"using ModelingToolkitStandardLibrary.Blocks, ModelingToolkit\n@named P = FirstOrder(k = 1, T = 1) # A first-order system with pole in -1\n@named C = Gain(-1)             # A P controller\nt = ModelingToolkit.get_iv(P)\neqs = [connect(P.output, :plant_output, C.input)  # Connect with an automatically created analysis point called :plant_output\n       connect(C.output, :plant_input, P.input)]\nsys = ODESystem(eqs, t, systems = [P, C], name = :feedback_system)\n\nmatrices_S = get_sensitivity(sys, :plant_input)[1] # Compute the matrices of a state-space representation of the (input)sensitivity function.\nmatrices_T = get_comp_sensitivity(sys, :plant_input)[1]","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"Continued linear analysis and design can be performed using ControlSystemsBase.jl. We create ControlSystemsBase.StateSpace objects using","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"using ControlSystemsBase, Plots\nS = ss(matrices_S...)\nT = ss(matrices_T...)\nbodeplot([S, T], lab = [\"S\" \"\" \"T\" \"\"], plot_title = \"Bode plot of sensitivity functions\",\n    margin = 5Plots.mm)","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"The sensitivity functions obtained this way should be equivalent to the ones obtained with the code below","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"using ControlSystemsBase\nP = tf(1.0, [1, 1]) |> ss\nC = 1                      # Negative feedback assumed in ControlSystems\nS = sensitivity(P, C)      # or feedback(1, P*C)\nT = comp_sensitivity(P, C) # or feedback(P*C)","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"We may also derive the loop-transfer function L(s) = P(s)C(s) using","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"matrices_L = get_looptransfer(sys, :plant_output)[1]\nL = ss(matrices_L...)","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"which is equivalent to the following with ControlSystems","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"L = P * (-C) # Add the minus sign to build the negative feedback into the controller","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"To obtain the transfer function between two analysis points, we call linearize","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"using ModelingToolkit # hide\nmatrices_PS = linearize(sys, :plant_input, :plant_output)[1]","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"this particular transfer function should be equivalent to the linear system P(s)S(s), i.e., equivalent to","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"feedback(P, C)","category":"page"},{"location":"API/linear_analysis/#Obtaining-transfer-functions","page":"Linear Analysis","title":"Obtaining transfer functions","text":"","category":"section"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"A statespace system from ControlSystemsBase can be converted to a transfer function using the function tf:","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"tf(S)","category":"page"},{"location":"API/linear_analysis/#Gain-and-phase-margins","page":"Linear Analysis","title":"Gain and phase margins","text":"","category":"section"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"Further linear analysis can be performed using the analysis methods from ControlSystemsBase. For example, calculating the gain and phase margins of a system can be done using","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"margin(P)","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"(they are infinite for this system). A Nyquist plot can be produced using","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"nyquistplot(P)","category":"page"},{"location":"API/linear_analysis/#Index","page":"Linear Analysis","title":"Index","text":"","category":"section"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"Pages = [\"linear_analysis.md\"]","category":"page"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"Modules = [ModelingToolkitStandardLibrary.Blocks]\nPages   = [\"Blocks/analysis_points.jl\"]\nOrder   = [:function, :type]\nPrivate = false","category":"page"},{"location":"API/linear_analysis/#ModelingToolkitStandardLibrary.Blocks.get_comp_sensitivity","page":"Linear Analysis","title":"ModelingToolkitStandardLibrary.Blocks.get_comp_sensitivity","text":"get_comp_sensitivity(sys, ap::AnalysisPoint; kwargs)\nget_comp_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the complementary sensitivity function in analysis point ap. The complementary sensitivity function is obtained by introducing an infinitesimal perturbation d at the output of ap, linearizing the system and computing the transfer function between d and the input of ap.\n\ndanger: Experimental\nThe analysis-point interface is currently experimental and at any time subject to breaking changes not respecting semantic versioning.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"API/linear_analysis/#ModelingToolkitStandardLibrary.Blocks.get_looptransfer","page":"Linear Analysis","title":"ModelingToolkitStandardLibrary.Blocks.get_looptransfer","text":"get_looptransfer(sys, ap::AnalysisPoint; kwargs)\nget_looptransfer(sys, ap_name::Symbol; kwargs)\n\nCompute the (linearized) loop-transfer function in analysis point ap, from ap.out to ap.in.\n\ninfo: Negative feedback\nFeedback loops often use negative feedback, and the computed loop-transfer function will in this case have the negative feedback included. Standard analysis tools often assume a loop-transfer function without the negative gain built in, and the result of this function may thus need negation before use.\n\ndanger: Experimental\nThe analysis-point interface is currently experimental and at any time subject to breaking changes not respecting semantic versioning.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_comp_sensitivity, open_loop.\n\n\n\n\n\n","category":"function"},{"location":"API/linear_analysis/#ModelingToolkitStandardLibrary.Blocks.get_sensitivity","page":"Linear Analysis","title":"ModelingToolkitStandardLibrary.Blocks.get_sensitivity","text":"get_sensitivity(sys, ap::AnalysisPoint; kwargs)\nget_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the sensitivity function in analysis point ap. The sensitivity function is obtained by introducing an infinitesimal perturbation d at the input of ap, linearizing the system and computing the transfer function between d and the output of ap.\n\ndanger: Experimental\nThe analysis-point interface is currently experimental and at any time subject to breaking changes not respecting semantic versioning.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_comp_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"API/linear_analysis/#ModelingToolkitStandardLibrary.Blocks.open_loop-Tuple{Any, Symbol}","page":"Linear Analysis","title":"ModelingToolkitStandardLibrary.Blocks.open_loop","text":"open_sys = open_loop(sys, ap::AnalysisPoint; kwargs)\nopen_sys = open_loop(sys, ap_name::Symbol; kwargs)\n\nOpen the loop at analysis point ap by breaking the connection through ap.\n\nopen_sys will have u ~ ap.out as input and y ~ ap.in as output.\n\ndanger: Experimental\nThe analysis-point interface is currently experimental and at any time subject to breaking changes not respecting semantic versioning.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_comp_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"method"},{"location":"API/linear_analysis/#ModelingToolkitStandardLibrary.Blocks.AnalysisPoint-Tuple{Any, Any}","page":"Linear Analysis","title":"ModelingToolkitStandardLibrary.Blocks.AnalysisPoint","text":"AnalysisPoint(in, out, name::Symbol)\nAnalysisPoint(in, out; name::Symbol)\nAnalysisPoint(name::Symbol)\n\nCreate an AnalysisPoint for linear analysis. Analysis points can also be created automatically by calling\n\nconnect(in, :ap_name, out)\n\ndanger: Experimental\nThe analysis-point interface is currently experimental and at any time subject to breaking changes not respecting semantic versioning.\n\nArguments:\n\nin: A connector of type RealOutput.\nout: A connector of type RealInput.\nname: The name of the analysis point.\n\nSee also get_sensitivity, get_comp_sensitivity, get_looptransfer, open_loop\n\nExample\n\nusing ModelingToolkitStandardLibrary.Blocks\n@named P = FirstOrder(k = 1, T = 1)\n@named C = Gain(; k = -1)\nt = ModelingToolkit.get_iv(P)\neqs = [connect(P.output, C.input)\n       connect(C.output, :plant_input, P.input)]\nsys = ODESystem(eqs, t, systems = [P, C], name = :feedback_system)\n\nmatrices_S, _ = get_sensitivity(sys, :plant_input) # Compute the matrices of a state-space representation of the (input) sensitivity function.\nmatrices_T, _ = get_comp_sensitivity(sys, :plant_input)\n\nContinued linear analysis and design can be performed using ControlSystemsBase.jl. Create ControlSystemsBase.StateSpace objects using\n\nusing ControlSystemsBase, Plots\nS = ss(matrices_S...)\nT = ss(matrices_T...)\nbodeplot([S, T], lab = [\"S\" \"T\"])\n\nThe sensitivity functions obtained this way should be equivalent to the ones obtained with the code below\n\nusing ControlSystemsBase\nP = tf(1.0, [1, 1])\nC = 1                      # Negative feedback assumed in ControlSystems\nS = sensitivity(P, C)      # or feedback(1, P*C)\nT = comp_sensitivity(P, C) # or feedback(P*C)\n\n\n\n\n\n","category":"method"},{"location":"API/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"ModelingToolkit.linearize","category":"page"},{"location":"API/linear_analysis/#ModelingToolkit.linearize","page":"Linear Analysis","title":"ModelingToolkit.linearize","text":"(; A, B, C, D), simplified_sys = linearize(sys, inputs, outputs;    t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false, kwargs...)\n(; A, B, C, D)                 = linearize(simplified_sys, lin_fun; t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false)\n\nLinearize sys between inputs and outputs, both vectors of variables. Return a NamedTuple with the matrices of a linear statespace representation on the form\n\nbeginaligned\nx = Ax + Bu\ny = Cx + Du\nendaligned\n\nThe first signature automatically calls linearization_function internally, while the second signature expects the outputs of linearization_function as input.\n\nop denotes the operating point around which to linearize. If none is provided, the default values of sys are used.\n\nIf allow_input_derivatives = false, an error will be thrown if input derivatives (u) appear as inputs in the linearized equations. If input derivatives are allowed, the returned B matrix will be of double width, corresponding to the input [u; u̇].\n\nzero_dummy_der can be set to automatically set the operating point to zero for all dummy derivatives.\n\nSee also linearization_function which provides a lower-level interface, linearize_symbolic and ModelingToolkit.reorder_unknowns.\n\nSee extended help for an example.\n\nThe implementation and notation follows that of \"Linear Analysis Approach for Modelica Models\", Allain et al. 2009\n\nExtended help\n\nThis example builds the following feedback interconnection and linearizes it from the input of F to the output of P.\n\n\n  r ┌─────┐       ┌─────┐     ┌─────┐\n───►│     ├──────►│     │  u  │     │\n    │  F  │       │  C  ├────►│  P  │ y\n    └─────┘     ┌►│     │     │     ├─┬─►\n                │ └─────┘     └─────┘ │\n                │                     │\n                └─────────────────────┘\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction plant(; name)\n    @variables x(t) = 1\n    @variables u(t)=0 y(t)=0\n    eqs = [D(x) ~ -x + u\n           y ~ x]\n    ODESystem(eqs, t; name = name)\nend\n\nfunction ref_filt(; name)\n    @variables x(t)=0 y(t)=0\n    @variables u(t)=0 [input = true]\n    eqs = [D(x) ~ -2 * x + u\n           y ~ x]\n    ODESystem(eqs, t, name = name)\nend\n\nfunction controller(kp; name)\n    @variables y(t)=0 r(t)=0 u(t)=0\n    @parameters kp = kp\n    eqs = [\n        u ~ kp * (r - y),\n    ]\n    ODESystem(eqs, t; name = name)\nend\n\n@named f = ref_filt()\n@named c = controller(1)\n@named p = plant()\n\nconnections = [f.y ~ c.r # filtered reference to controller reference\n               c.u ~ p.u # controller output to plant input\n               p.y ~ c.y]\n\n@named cl = ODESystem(connections, t, systems = [f, c, p])\n\nlsys0, ssys = linearize(cl, [f.u], [p.x])\ndesired_order = [f.x, p.x]\nlsys = ModelingToolkit.reorder_unknowns(lsys0, unknowns(ssys), desired_order)\n\n@assert lsys.A == [-2 0; 1 -2]\n@assert lsys.B == [1; 0;;]\n@assert lsys.C == [0 1]\n@assert lsys.D[] == 0\n\n## Symbolic linearization\nlsys_sym, _ = ModelingToolkit.linearize_symbolic(cl, [f.u], [p.x])\n\n@assert substitute(lsys_sym.A, ModelingToolkit.defaults(cl)) == lsys.A\n\n\n\n\n\nModelingToolkit.linearize(sys, input_name::Symbol, output_name; kwargs...)\n\nLinearize a system between two analysis points. To get a loop-transfer function, see get_looptransfer.\n\nThe output is allowed to be either an analysis-point name, or a vector of symbolic variables like the standard interface to linearize. The input must be an analysis-point name.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/input_component/#Building-Models-with-Discrete-Data,-Interpolations,-and-Lookup-Tables","page":"SampledData Component","title":"Building Models with Discrete Data, Interpolations, and Lookup Tables","text":"","category":"section"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"There are 4 ways to include data as part of a model.","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"using ModelingToolkitStandardLibrary.Blocks.Interpolation\nusing ModelingToolkitStandardLibrary.Blocks.ParametrizedInterpolation\nusing a custom component with external data (not recommended)\nusing ModelingToolkitStandardLibrary.Blocks.SampledData (legacy)","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"This tutorial demonstrate each case and explain the pros and cons of each.","category":"page"},{"location":"tutorials/input_component/#Interpolation-Block","page":"SampledData Component","title":"Interpolation Block","text":"","category":"section"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"The ModelingToolkitStandardLibrary.Blocks.Interpolation component is easy to use and is performant. It is similar to using callable parameters, but it provides a block interface with RealInput and RealOutput connectors. The Interpolation is compatible with interpolation types from DataInterpolation.","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"ModelingToolkitStandardLibrary.Blocks.Interpolation","category":"page"},{"location":"tutorials/input_component/#ModelingToolkitStandardLibrary.Blocks.Interpolation","page":"SampledData Component","title":"ModelingToolkitStandardLibrary.Blocks.Interpolation","text":"Interpolation(interp_type, u, x, args...; name)\n\nRepresent function interpolation symbolically as a block component. By default interpolation types from DataInterpolations.jl are supported, but in general any callable type that builds the interpolation object via itp = interpolation_type(u, x, args...) and calls the interpolation with itp(t) should work. This does not need to represent an interpolation, it can be any type that satisfies the interface, such as lookup tables.\n\nArguments:\n\ninterp_type: the type of the interpolation. For DataInterpolations,\n\nthese would be any of the available interpolations, such as LinearInterpolation, ConstantInterpolation or CubicSpline.\n\nu: the data used for interpolation. For DataInterpolations this will be an AbstractVector\nx: the values that each data points correspond to, usually the times corresponding to each value in u.\nargs: any other arguments needed to build the interpolation\n\nKeyword arguments:\n\nname: the name of the component\n\nParameters:\n\ninterpolator: the symbolic representation of the interpolation object, callable as interpolator(t)\n\nConnectors:\n\ninput: a RealInput connector corresponding to the input variable\noutput: a RealOutput connector corresponding to the interpolated value\n\n\n\n\n\n","category":"function"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"Here is an example on how to use it. Let's consider a mass-spring-damper system, where we have an external force as an input. We then generate some example data in a DataFrame that would represent a measurement of the input. In a more realistic case, this DataFrame would be read from a file.","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing ModelingToolkitStandardLibrary.Blocks\nusing DataInterpolations\nusing OrdinaryDiffEq\nusing DataFrames\nusing Plots\n\nfunction MassSpringDamper(; name)\n    @named input = RealInput()\n    @variables f(t)=0 x(t)=0 dx(t)=0 ddx(t)=0\n    @parameters m=10 k=1000 d=1\n\n    eqs = [\n           f ~ input.u\n           ddx * 10 ~ k * x + d * dx + f\n           D(x) ~ dx\n           D(dx) ~ ddx]\n\n    ODESystem(eqs, t; name, systems = [input])\nend\n\nfunction MassSpringDamperSystem(data, time; name)\n    @named src = Interpolation(LinearInterpolation, data, time)\n    @named clk = ContinuousClock()\n    @named model = MassSpringDamper()\n\n    eqs = [\n        connect(src.input, clk.output)\n        connect(src.output, model.input)\n    ]\n\n    ODESystem(eqs, t, [], []; name, systems = [src, clk, model])\nend\n\nfunction generate_data()\n    dt = 4e-4\n    time = 0:dt:0.1\n    data = sin.(2 * pi * time * 100)\n\n    return DataFrame(; time, data)\nend\n\ndf = generate_data() # example data\n\n@named system = MassSpringDamperSystem(df.data, df.time)\nsys = structural_simplify(system)\nprob = ODEProblem(sys, [], (0, df.time[end]))\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"tutorials/input_component/#ParametrizedInterpolation-Block","page":"SampledData Component","title":"ParametrizedInterpolation Block","text":"","category":"section"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"The ModelingToolkitStandardLibrary.Blocks.ParametrizedInterpolation component is similar to Interpolation, but as the name suggests, it is parametrized by the data, allowing one to change the underlying data without rebuilding the model as the data is represented via vector parameters. The main advantage of this block over the Interpolation one is that one can use it for optimization problems. Currently, this supports forward mode AD via ForwardDiff, but due to the increased flexibility of the types in the component, this is not as fast as the Interpolation block, so it is recommended to use only when the added flexibility is required.","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"ModelingToolkitStandardLibrary.Blocks.ParametrizedInterpolation","category":"page"},{"location":"tutorials/input_component/#ModelingToolkitStandardLibrary.Blocks.ParametrizedInterpolation","page":"SampledData Component","title":"ModelingToolkitStandardLibrary.Blocks.ParametrizedInterpolation","text":"ParametrizedInterpolation(interp_type, u, x, args...; name, t = ModelingToolkit.t_nounits)\n\nRepresent function interpolation symbolically as a block component, with the interpolation data represented parametrically. By default interpolation types from DataInterpolations.jl are supported, but in general any callable type that builds the interpolation object via itp = interpolation_type(u, x, args...) and calls the interpolation with itp(t) should work. This does not need to represent an interpolation, it can be any type that satisfies the interface, such as lookup tables.\n\nArguments:\n\ninterp_type: the type of the interpolation. For DataInterpolations,\n\nthese would be any of the available interpolations, such as LinearInterpolation, ConstantInterpolation or CubicSpline.\n\nu: the data used for interpolation. For DataInterpolations this will be an AbstractVector\nx: the values that each data points correspond to, usually the times corresponding to each value in u.\nargs: any other arguments beeded to build the interpolation\n\nKeyword arguments:\n\nname: the name of the component\n\nParameters:\n\ndata: the symbolic representation of the data passed at construction time via u.\nts: the symbolic representation of times corresponding to the data passed at construction time via x.\n\nConnectors:\n\ninput: a RealInput connector corresponding to the independent variable\noutput: a RealOutput connector corresponding to the interpolated value\n\n\n\n\n\n","category":"function"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"Here is an example on how to use it","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing ModelingToolkitStandardLibrary.Blocks\nusing DataInterpolations\nusing OrdinaryDiffEq\nusing DataFrames\nusing Plots\n\nfunction MassSpringDamper(; name)\n    @named input = RealInput()\n    vars = @variables f(t) x(t)=0 dx(t) [guess=0] ddx(t)\n    pars = @parameters m=10 k=1000 d=1\n\n    eqs = [\n           f ~ input.u\n           ddx * 10 ~ k * x + d * dx + f\n           D(x) ~ dx\n           D(dx) ~ ddx]\n\n    ODESystem(eqs, t, vars, pars; name, systems = [input])\nend\n\nfunction MassSpringDamperSystem(data, time; name)\n    @named src = ParametrizedInterpolation(LinearInterpolation, data, time)\n    @named clk = ContinuousClock()\n    @named model = MassSpringDamper()\n\n    eqs = [\n        connect(model.input, src.output)\n        connect(src.input, clk.output)\n    ]\n\n    ODESystem(eqs, t; name, systems = [src, clk, model])\nend\n\nfunction generate_data()\n    dt = 4e-4\n    time = 0:dt:0.1\n    data = sin.(2 * pi * time * 100)\n\n    return DataFrame(; time, data)\nend\n\ndf = generate_data() # example data\n\n@named system = MassSpringDamperSystem(df.data, df.time)\nsys = structural_simplify(system)\nprob = ODEProblem(sys, [], (0, df.time[end]))\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"If we want to run a new data set, this requires only remaking the problem and solving again","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"prob2 = remake(prob, p = [sys.src.data => ones(length(df.data))])\nsol2 = solve(prob2)\nplot(sol2)","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"note: Note\nNote that when changing the data, the length of the new data must be the same as the length of the original data.","category":"page"},{"location":"tutorials/input_component/#Custom-Component-with-External-Data","page":"SampledData Component","title":"Custom Component with External Data","text":"","category":"section"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"The below code shows how to include data using a Ref and registered get_sampled_data function.  This example uses a very basic function which requires non-adaptive solving and sampled data.  As can be seen, the data can easily be set and changed before solving.","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing ModelingToolkitStandardLibrary.Blocks\nusing OrdinaryDiffEq\n\nconst rdata = Ref{Vector{Float64}}()\n\ndt = 4e-4\ntime = 0:dt:0.1\n# Data Sets\ndata1 = sin.(2 * pi * time * 100)\ndata2 = cos.(2 * pi * time * 50)\n\nfunction get_sampled_data(t)\n    i = floor(Int, t / dt) + 1\n    x = rdata[][i]\n\n    return x\nend\n\nSymbolics.@register_symbolic get_sampled_data(t)\n\nfunction System(; name)\n    vars = @variables f(t)=0 x(t)=0 dx(t)=0 ddx(t)=0\n    pars = @parameters m=10 k=1000 d=1\n\n    eqs = [f ~ get_sampled_data(t)\n           ddx * 10 ~ k * x + d * dx + f\n           D(x) ~ dx\n           D(dx) ~ ddx]\n\n    ODESystem(eqs, t, vars, pars; name)\nend\n\n@named system = System()\nsys = structural_simplify(system)\nprob = ODEProblem(sys, [], (0, time[end]))\n\nrdata[] = data1\nsol1 = solve(prob, ImplicitEuler(); dt, adaptive = false)\nddx1 = sol1[sys.ddx]\n\nrdata[] = data2\nsol2 = solve(prob, ImplicitEuler(); dt, adaptive = false)\nddx2 = sol2[sys.ddx]","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"The drawback of this method is that the solution observables can be linked to the data Ref, which means that if the data changes then the observables are no longer valid.  In this case ddx is an observable that is derived directly from the data.  Therefore, sol1[sys.ddx] is no longer correct after the data is changed for sol2.","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"# the following test will fail\n@test all(ddx1 .== sol1[sys.ddx]) #returns false","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"Additional code could be added to resolve this issue, for example by using a Ref{Dict} that could link a parameter of the model to the data source.  This would also be necessary for parallel processing.","category":"page"},{"location":"tutorials/input_component/#SampledData-Component","page":"SampledData Component","title":"SampledData Component","text":"","category":"section"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"To resolve the issues presented above, the ModelingToolkitStandardLibrary.Blocks.SampledData component can be used which allows for a resusable ODESystem and self contained data which ensures a solution which remains valid for it's lifetime.  Now it's possible to also parallelize the call to solve().","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing ModelingToolkitStandardLibrary.Blocks\nusing OrdinaryDiffEq\n\nfunction System(; name)\n    src = SampledData(Float64, name=:src)\n\n    vars = @variables f(t)=0 x(t)=0 dx(t)=0 ddx(t)=0\n    pars = @parameters m=10 k=1000 d=1\n\n    eqs = [f ~ src.output.u\n           ddx * 10 ~ k * x + d * dx + f\n           D(x) ~ dx\n           D(dx) ~ ddx]\n\n    ODESystem(eqs, t, vars, pars; systems = [src], name)\nend\n\n@named system = System()\nsys = structural_simplify(system, split=false)\ns = complete(system)\n\ndt = 4e-4\ntime = 0:dt:0.1\ndata1 = sin.(2 * pi * time * 100)\ndata2 = cos.(2 * pi * time * 50)\n\nprob = ODEProblem(sys, [], (0, time[end]); split=false, tofloat = false, use_union=true)\ndefs = ModelingToolkit.defaults(sys)\n\nfunction get_prob(data)\n    defs[s.src.buffer] = Parameter(data, dt)\n    # ensure p is a uniform type of Vector{Parameter{Float64}} (converting from Vector{Any})\n    p = Parameter.(ModelingToolkit.varmap_to_vars(defs, parameters(sys); tofloat = false))\n    remake(prob; p, build_initializeprob=false)\nend\n\nprob1 = get_prob(data1)\nprob2 = get_prob(data2)\n\nsol1 = Ref{ODESolution}()\nsol2 = Ref{ODESolution}()\n@sync begin\n    @async sol1[] = solve(prob1, ImplicitEuler())\n    @async sol2[] = solve(prob2, ImplicitEuler())\nend","category":"page"},{"location":"tutorials/input_component/","page":"SampledData Component","title":"SampledData Component","text":"Note, in the above example, we can build the system with an empty SampledData component, only setting the expected data type: @named src = SampledData(Float64).  It's also possible to initialize the component with real sampled data: @named src = SampledData(data, dt).  Additionally note that before running an ODEProblem using the SampledData component, one must be careful about the parameter vector Type.  The SampledData component contains a buffer parameter of type Parameter, therefore we must generate the problem using tofloat=false.  This will initially give a parameter vector of type Vector{Any} with a mix of numbers and Parameter type.  We can convert the vector to a uniform Parameter type by running p = Parameter.(p).  This will wrap all the single values in a Parameter which will be mathematically equivalent to a Number.","category":"page"},{"location":"#ModelingToolkitStandardLibrary.jl","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl","text":"","category":"section"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"ModelingToolkitStandardLibrary.jl is a standard library for the ModelingToolkit acausal modeling system.","category":"page"},{"location":"#Installation","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"Installation","text":"","category":"section"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"To install ModelingToolkitStandardLibrary.jl, use the Julia package manager:","category":"page"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"using Pkg\nPkg.add(\"ModelingToolkitStandardLibrary\")","category":"page"},{"location":"#Tutorials","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"Tutorials","text":"","category":"section"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"RC Circuit\nCustom Component\nThermal Model\nDC Motor with PI-controller","category":"page"},{"location":"#Libraries","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"Libraries","text":"","category":"section"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"The following are the constituent libraries of the ModelingToolkit Standard Library.","category":"page"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"Basic Blocks\nMechanical Components\nElectrical Components\nMagnetic Components\nThermal Components\nHydraulic Components","category":"page"},{"location":"#Contributing","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"Contributing","text":"","category":"section"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"</details>","category":"page"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"</details>","category":"page"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"</details>","category":"page"},{"location":"","page":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","title":"ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"}]
}
