<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Analysis · ModelingToolkitStandardLibrary.jl</title><meta name="title" content="Linear Analysis · ModelingToolkitStandardLibrary.jl"/><meta property="og:title" content="Linear Analysis · ModelingToolkitStandardLibrary.jl"/><meta property="twitter:title" content="Linear Analysis · ModelingToolkitStandardLibrary.jl"/><meta name="description" content="Documentation for ModelingToolkitStandardLibrary.jl."/><meta property="og:description" content="Documentation for ModelingToolkitStandardLibrary.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkitStandardLibrary.jl."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/API/linear_analysis/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/API/linear_analysis/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/API/linear_analysis/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ModelingToolkitStandardLibrary.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkitStandardLibrary.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">ModelingToolkitStandardLibrary.jl: A Standard Library for ModelingToolkit</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/rc_circuit/">RC Circuit</a></li><li><a class="tocitem" href="../../tutorials/custom_component/">Custom Components</a></li><li><a class="tocitem" href="../../tutorials/thermal_model/">Thermal Conduction Model</a></li><li><a class="tocitem" href="../../tutorials/dc_motor_pi/">DC Motor with Speed Controller</a></li><li><a class="tocitem" href="../../tutorials/input_component/">SampledData Component</a></li></ul></li><li><span class="tocitem">About Acausal Connections</span><ul><li><a class="tocitem" href="../../connectors/connections/">Theory</a></li><li><a class="tocitem" href="../../connectors/sign_convention/">Sign Convention</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../blocks/">Basic Blocks</a></li><li><a class="tocitem" href="../electrical/">Electrical Components</a></li><li><a class="tocitem" href="../magnetic/">Magnetic Components</a></li><li><a class="tocitem" href="../mechanical/">Mechanical Components</a></li><li><a class="tocitem" href="../thermal/">Thermal Components</a></li><li><a class="tocitem" href="../hydraulic/">Hydraulic Components</a></li><li class="is-active"><a class="tocitem" href>Linear Analysis</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Gain-and-phase-margins"><span>Gain and phase margins</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Linear Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitStandardLibrary.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkitStandardLibrary.jl/blob/main/docs/src/API/linear_analysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-Analysis"><a class="docs-heading-anchor" href="#Linear-Analysis">Linear Analysis</a><a id="Linear-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Analysis" title="Permalink"></a></h1><div class="admonition is-danger" id="Experimental-c80247f9a8f93062"><header class="admonition-header">Experimental<a class="admonition-anchor" href="#Experimental-c80247f9a8f93062" title="Permalink"></a></header><div class="admonition-body"><p>The interface described here is currently experimental and at any time subject to breaking changes not respecting semantic versioning.</p></div></div><p>Linear analysis refers to the process of linearizing a nonlinear model and analysing the resulting linear dynamical system. To facilitate linear analysis, ModelingToolkitStandardLibrary provides the concept of an <a href="@ref"><code>AnalysisPoint</code></a>, which can be inserted in-between two causal blocks (such as those from the <code>Blocks</code> sub module). Once a model containing analysis points is built, several operations are available:</p><ul><li><a href="@ref"><code>get_sensitivity</code></a> get the <a href="https://en.wikipedia.org/wiki/Sensitivity_(control_systems)">sensitivity function (wiki)</a>, <span>$S(s)$</span>, as defined in the field of control theory.</li><li><a href="@ref"><code>get_comp_sensitivity</code></a> get the complementary sensitivity function <span>$T(s) : S(s)+T(s)=1$</span>.</li><li><a href="@ref"><code>get_looptransfer</code></a> get the (open) loop-transfer function where the loop starts and ends in the analysis point. For a typical simple feedback connection with a plant <span>$P(s)$</span> and a controller <span>$C(s)$</span>, the loop-transfer function at the plant output is <span>$P(s)C(s)$</span>.</li><li><a href="#ModelingToolkit.linearize"><code>linearize</code></a> can be called with two analysis points denoting the input and output of the linearized system.</li><li><a href="@ref"><code>open_loop</code></a> return a new (nonlinear) system where the loop has been broken in the analysis point, i.e., the connection the analysis point usually implies has been removed.</li></ul><p>An analysis point can be created explicitly using the constructor <a href="@ref"><code>AnalysisPoint</code></a>, or automatically when connecting two causal components using <code>connect</code>:</p><pre><code class="language-julia hljs">connect(comp1.output, :analysis_point_name, comp2.input)</code></pre><div class="admonition is-warning" id="Causality-71bac6a0b05f64e1"><header class="admonition-header">Causality<a class="admonition-anchor" href="#Causality-71bac6a0b05f64e1" title="Permalink"></a></header><div class="admonition-body"><p>Analysis points are <em>causal</em>, i.e., they imply a directionality for the flow of information. The order of the connections in the connect statement is thus important, i.e., <code>connect(out, :name, in)</code> is different from <code>connect(in, :name, out)</code>.</p></div></div><p>The directionality of an analysis point can be thought of as an arrow in a block diagram, where the name of the analysis point applies to the arrow itself.</p><pre><code class="nohighlight hljs">┌─────┐         ┌─────┐
│     │  name   │     │
│  out├────────►│in   │
│     │         │     │
└─────┘         └─────┘</code></pre><p>This is signified by the name being the middle argument to <code>connect</code>.</p><p>Of the above mentioned functions, all except for <a href="@ref"><code>open_loop</code></a> return the output of <a href="#ModelingToolkit.linearize"><code>ModelingToolkit.linearize</code></a>, which is</p><pre><code class="language-julia hljs">matrices, simplified_sys = linearize(...)
# matrices = (; A, B, C, D)</code></pre><p>i.e., <code>matrices</code> is a named tuple containing the matrices of a linear state-space system on the form</p><p class="math-container">\[\begin{aligned}
\dot x &amp;= Ax + Bu\\
y &amp;= Cx + Du
\end{aligned}\]</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>The following example builds a simple closed-loop system with a plant <span>$P$</span> and a controller <span>$C$</span>. Two analysis points are inserted, one before and one after <span>$P$</span>. We then derive a number of sensitivity functions and show the corresponding code using the package ControlSystemBase.jl</p><pre><code class="language-julia hljs">using ModelingToolkitStandardLibrary.Blocks, ModelingToolkit
@named P = FirstOrder(k = 1, T = 1) # A first-order system with pole in -1
@named C = Gain(-1)             # A P controller
t = ModelingToolkit.get_iv(P)
eqs = [connect(P.output, :plant_output, C.input)  # Connect with an automatically created analysis point called :plant_output
       connect(C.output, :plant_input, P.input)]
sys = System(eqs, t, systems = [P, C], name = :feedback_system)

matrices_S = get_sensitivity(sys, :plant_input)[1] # Compute the matrices of a state-space representation of the (input)sensitivity function.
matrices_T = get_comp_sensitivity(sys, :plant_input)[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(A = [-2.0;;], B = [-1.0;;], C = [-1.0;;], D = [0.0;;])</code></pre><p>Continued linear analysis and design can be performed using ControlSystemsBase.jl. We create <code>ControlSystemsBase.StateSpace</code> objects using</p><pre><code class="language-julia hljs">using ControlSystemsBase, Plots
S = ss(matrices_S...)
T = ss(matrices_T...)
bodeplot([S, T], lab = [&quot;S&quot; &quot;&quot; &quot;T&quot; &quot;&quot;], plot_title = &quot;Bode plot of sensitivity functions&quot;,
    margin = 5Plots.mm)</code></pre><img src="87e2cbc5.svg" alt="Example block output"/><p>The sensitivity functions obtained this way should be equivalent to the ones obtained with the code below</p><pre><code class="language-julia hljs">using ControlSystemsBase
P = tf(1.0, [1, 1]) |&gt; ss
C = 1                      # Negative feedback assumed in ControlSystems
S = sensitivity(P, C)      # or feedback(1, P*C)
T = comp_sensitivity(P, C) # or feedback(P*C)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ControlSystemsBase.StateSpace{ControlSystemsBase.Continuous, Float64}
A = 
 -2.0
B = 
 1.0
C = 
 1.0
D = 
 0.0

Continuous-time state-space model</code></pre><p>We may also derive the loop-transfer function <span>$L(s) = P(s)C(s)$</span> using</p><pre><code class="language-julia hljs">matrices_L = get_looptransfer(sys, :plant_output)[1]
L = ss(matrices_L...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ControlSystemsBase.StateSpace{ControlSystemsBase.Continuous, Float64}
A = 
 -1.0
B = 
 -1.0
C = 
 1.0
D = 
 0.0

Continuous-time state-space model</code></pre><p>which is equivalent to the following with ControlSystems</p><pre><code class="language-julia hljs">L = P * (-C) # Add the minus sign to build the negative feedback into the controller</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ControlSystemsBase.StateSpace{ControlSystemsBase.Continuous, Float64}
A = 
 -1.0
B = 
 -1.0
C = 
 1.0
D = 
 -0.0

Continuous-time state-space model</code></pre><p>To obtain the transfer function between two analysis points, we call <code>linearize</code></p><pre><code class="language-julia hljs">matrices_PS = linearize(sys, :plant_input, :plant_output)[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(A = [-2.0;;], B = [1.0;;], C = [1.0;;], D = [0.0;;])</code></pre><p>this particular transfer function should be equivalent to the linear system <code>P(s)S(s)</code>, i.e., equivalent to</p><pre><code class="language-julia hljs">feedback(P, C)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ControlSystemsBase.StateSpace{ControlSystemsBase.Continuous, Float64}
A = 
 -2.0
B = 
 1.0
C = 
 1.0
D = 
 0.0

Continuous-time state-space model</code></pre><h3 id="Obtaining-transfer-functions"><a class="docs-heading-anchor" href="#Obtaining-transfer-functions">Obtaining transfer functions</a><a id="Obtaining-transfer-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-transfer-functions" title="Permalink"></a></h3><p>A statespace system from <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/man/creating_systems/">ControlSystemsBase</a> can be converted to a transfer function using the function <code>tf</code>:</p><pre><code class="language-julia hljs">tf(S)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ControlSystemsBase.TransferFunction{ControlSystemsBase.Continuous, ControlSystemsBase.SisoRational{Float64}}
1.0s + 1.0
----------
1.0s + 2.0

Continuous-time transfer function model</code></pre><h2 id="Gain-and-phase-margins"><a class="docs-heading-anchor" href="#Gain-and-phase-margins">Gain and phase margins</a><a id="Gain-and-phase-margins-1"></a><a class="docs-heading-anchor-permalink" href="#Gain-and-phase-margins" title="Permalink"></a></h2><p>Further linear analysis can be performed using the <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/lib/analysis/">analysis methods from ControlSystemsBase</a>. For example, calculating the gain and phase margins of a system can be done using</p><pre><code class="language-julia hljs">margin(P)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(wgm = [NaN;;], gm = [Inf;;], wpm = [NaN;;], pm = [Inf;;])</code></pre><p>(they are infinite for this system). A Nyquist plot can be produced using</p><pre><code class="language-julia hljs">nyquistplot(P)</code></pre><img src="de91d4cc.svg" alt="Example block output"/><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#ModelingToolkit.linearize"><code>ModelingToolkit.linearize</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.linearize" href="#ModelingToolkit.linearize"><code>ModelingToolkit.linearize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(; A, B, C, D), simplified_sys, extras = linearize(sys, inputs, outputs;    t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false, kwargs...)
(; A, B, C, D), extras                 = linearize(simplified_sys, lin_fun; t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false)</code></pre><p>Linearize <code>sys</code> between <code>inputs</code> and <code>outputs</code>, both vectors of variables. Return a NamedTuple with the matrices of a linear statespace representation on the form</p><p class="math-container">\[\begin{aligned}
ẋ &amp;= Ax + Bu\\
y &amp;= Cx + Du
\end{aligned}\]</p><p>The first signature automatically calls <a href="@ref"><code>linearization_function</code></a> internally, while the second signature expects the outputs of <a href="@ref"><code>linearization_function</code></a> as input.</p><p><code>op</code> denotes the operating point around which to linearize. If none is provided, the default values of <code>sys</code> are used.</p><p>If <code>allow_input_derivatives = false</code>, an error will be thrown if input derivatives (<span>$u̇$</span>) appear as inputs in the linearized equations. If input derivatives are allowed, the returned <code>B</code> matrix will be of double width, corresponding to the input <code>[u; u̇]</code>.</p><p><code>zero_dummy_der</code> can be set to automatically set the operating point to zero for all dummy derivatives.</p><p>The return value <code>extras</code> is a NamedTuple <code>(; x, p, t)</code> containing the result of the initialization problem that was solved to determine the operating point.</p><p>See also <a href="@ref"><code>linearization_function</code></a> which provides a lower-level interface, <a href="@ref"><code>linearize_symbolic</code></a> and <a href="@ref"><code>ModelingToolkit.reorder_unknowns</code></a>.</p><p>See extended help for an example.</p><p>The implementation and notation follows that of <a href="https://ep.liu.se/ecp/043/075/ecp09430097.pdf">&quot;Linear Analysis Approach for Modelica Models&quot;, Allain et al. 2009</a></p><p><strong>Extended help</strong></p><p>This example builds the following feedback interconnection and linearizes it from the input of <code>F</code> to the output of <code>P</code>.</p><pre><code class="nohighlight hljs">
  r ┌─────┐       ┌─────┐     ┌─────┐
───►│     ├──────►│     │  u  │     │
    │  F  │       │  C  ├────►│  P  │ y
    └─────┘     ┌►│     │     │     ├─┬─►
                │ └─────┘     └─────┘ │
                │                     │
                └─────────────────────┘</code></pre><pre><code class="language-julia hljs">using ModelingToolkit
using ModelingToolkit: t_nounits as t, D_nounits as D
function plant(; name)
    @variables x(t) = 1
    @variables u(t)=0 y(t)=0
    eqs = [D(x) ~ -x + u
           y ~ x]
    System(eqs, t; name = name)
end

function ref_filt(; name)
    @variables x(t)=0 y(t)=0
    @variables u(t)=0 [input = true]
    eqs = [D(x) ~ -2 * x + u
           y ~ x]
    System(eqs, t, name = name)
end

function controller(kp; name)
    @variables y(t)=0 r(t)=0 u(t)=0
    @parameters kp = kp
    eqs = [
        u ~ kp * (r - y),
    ]
    System(eqs, t; name = name)
end

@named f = ref_filt()
@named c = controller(1)
@named p = plant()

connections = [f.y ~ c.r # filtered reference to controller reference
               c.u ~ p.u # controller output to plant input
               p.y ~ c.y]

@named cl = System(connections, t, systems = [f, c, p])

lsys0, ssys = linearize(cl, [f.u], [p.x])
desired_order = [f.x, p.x]
lsys = ModelingToolkit.reorder_unknowns(lsys0, unknowns(ssys), desired_order)

@assert lsys.A == [-2 0; 1 -2]
@assert lsys.B == [1; 0;;]
@assert lsys.C == [0 1]
@assert lsys.D[] == 0

## Symbolic linearization
lsys_sym, _ = ModelingToolkit.linearize_symbolic(cl, [f.u], [p.x])

@assert substitute(lsys_sym.A, ModelingToolkit.defaults(cl)) == lsys.A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v10.13.0/src/linearization.jl#L666-L766">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../hydraulic/">« Hydraulic Components</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 27 July 2025 01:59">Sunday 27 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
